#!/usr/bin/env python
# pylint: disable=C0111, C0103, C0413
#
# httpd - A simple HTTP server
#
#
# SYNOPSIS
# ========
#
#      httpd PORT
#
#
# DESCRIPTION
# ===========
#
# httpd serves files from test/data/http-server. This allows for the test
# suite to run even if Zotero and zotxt are not running. httpd only returns
# to the caller once the HTTP server accepts requests.
#
#
# FILES
# =====
#
#   test/data/http-server
#       Directory from which files are served.
#   test/run/http-server.pid
#       PID file.
#
# CAVEATS
# =======
#
# The Makefile tries to make sure that the server is shut down.
# It may fail at that though.
#
#
# SEE ALSO
# ========
#
# httpdctl
#
#
# AUTHOR
# ======
#
# Copyright 2019 Odin Kroeger
#
#
# LICENSE
# =======
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.


# CONSTANTS
# =========

# How long may the server take to start up, before we give up.
MAX_STARTUP_TIME = 5

# How long may the server take to shut down, before we kill it.
MAX_SHUTDOWN_TIME = 5


# LIBRARIES
# =========

try:
    import SimpleHTTPServer as server
except ModuleNotFoundError:
    import http.server as server

try:
    import SocketServer as socketserver
except ModuleNotFoundError:
    import socketserver

import argparse
import atexit
import os
import signal
import socket
import sys
import time


# INITIALISATION
# ==============

base_dir = os.path.realpath(os.path.join(os.path.split(sys.argv[0])[0], '..'))
data_dir = os.path.join(base_dir, 'data', 'http-server')
pid_fname = os.path.join(base_dir, 'run', 'http-server.pid')

if os.path.exists(pid_fname):
    rel_fname = pid_fname.replace(os.path.join(os.getcwd(), ''), '', 1)
    sys.stderr.write('httpd: {} exists.\n'.format(rel_fname))
    sys.exit(69)

parser = argparse.ArgumentParser(description='Starts a simle HTTP server.')
parser.add_argument('port', type=int, metavar='PORT')
args = parser.parse_args()

socketserver.TCPServer.allow_reuse_address = True
handler = server.SimpleHTTPRequestHandler
httpd = socketserver.TCPServer(('localhost', args.port), handler)


# PARENT
# ======

pid = os.fork()

if pid > 0:
    # Don't wait for the child, lest it becomes a zombie.
    signal.signal(signal.SIGCHLD, signal.SIG_IGN)

    # Try to reach the child, checking whether it accepts connections.
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    for i in range(MAX_STARTUP_TIME):
        if i > 1:
            time.sleep(1)
        try:
            s.connect(('localhost', args.port))
        except socket.error:
            continue
        s.close()
        break
    else:
        # If we reach this point, MAX_STARTUP_TIME has passed,
        # but we couldn't connect to the child, so we kill it.
        for i in range(MAX_SHUTDOWN_TIME):
            if i > 1:
                time.sleep(i)
            try:
                os.kill(pid, signal.SIGTERM)
            except OSError as err:
                if err.errno == 3:
                    break
        else:
            try:
                os.kill(pid, signal.SIGKILL)
            except OSError:
                pass
        sys.exit(1)
    sys.exit()


# CHILD
# =====

# Deamonise!
os.chdir(data_dir)
os.setsid()
os.umask(0o077)
for stream, mode in ((sys.stdin, 'r'), (sys.stdout, 'a+'), (sys.stderr, 'a+')):
    stream.flush()
    fd = open(os.devnull, mode)
    os.dup2(fd.fileno(), stream.fileno())

# Create the PID file.
atexit.register(os.unlink, pid_fname)
with open(pid_fname, 'w') as pid_file:
    pid_file.write('{!s}\n'.format(os.getpid()))

# Shutdown if we receive an INT or a TERM.
for signo in (signal.SIGTERM, signal.SIGINT):
    signal.signal(signo, httpd.shutdown)

httpd.serve_forever(0.1)
httpd.server_close()
