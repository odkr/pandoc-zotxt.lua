#!/usr/bin/env python
# pylint: disable = C0111, C0103, C0413
#
# httpd - A simple HTTP server
#
#
# SYNOPSIS
# ========
#
#      httpd PORT
#
#
# DESCRIPTION
# ===========
#
# httpd serves files from test/data/http-server. This allows for the test
# suite to run even if Zotero and zotxt are not running. httpd only returns
# to the caller once the HTTP server accepts requests.
#
#
# FILES
# =====
#
#   test/data/http-server
#       Directory from which files are served.
#   test/run/http-server.pid
#       PID file.
#
# CAVEATS
# =======
#
# The Makefile tries to make sure that the server is shut down.
# It may fail at that though.
#
#
# SEE ALSO
# ========
#
# httpdctl
#
#
# AUTHOR
# ======
#
# Copyright 2019 Odin Kroeger
#
#
# LICENSE
# =======
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.


# CONSTANTS
# =========

# How long may the server take to start up, before we give up.
MAX_STARTUP_TIME = 60

# How long may the server take to shut down, before we kill it.
MAX_SHUTDOWN_TIME = 5


# LIBRARIES
# =========

try:
    import SimpleHTTPServer as server
except ImportError:
    import http.server as server

try:
    import SocketServer as socketserver
except ImportError:
    import socketserver

try:
    import urllib.request as request
except ImportError:
    import urllib as request

import argparse
import atexit
import os
import signal
import sys
import time


# FUNCTIONS
# =========

# pylint: disable = W0621
def warn(msg, *args, **kwargs):
    sys.stderr.write(''.join(('httpd: ', msg.format(*args, **kwargs), '\n')))



# INITIALISATION
# ==============

base_dir = os.path.realpath(os.path.join(os.path.split(sys.argv[0])[0], '..'))
data_dir = os.path.join(base_dir, 'data', 'http-server')
pid_fname = os.path.join(base_dir, 'run', 'http-server.pid')

if os.path.exists(pid_fname):
    rel_fname = pid_fname.replace(os.path.join(os.getcwd(), ''), '', 1)
    warn('{} exists.', rel_fname)
    sys.exit(69)

parser = argparse.ArgumentParser(description='Starts a simle HTTP server.')
parser.add_argument('port', type=int, metavar='PORT')
args = parser.parse_args()


# PARENT
# ======

pid = os.fork()

if pid > 0:
    # Don't wait for the child, lest it becomes a zombie.
    signal.signal(signal.SIGCHLD, signal.SIG_IGN)

    # Wait until the child is ready to serve requests.
    try_until = time.time() + MAX_STARTUP_TIME
    while True:
        try:
            request.urlopen('http://localhost:{}'.format(args.port))
            break
        # pylint: disable=W0703
        except Exception as err:
            time.sleep(1)
            if time.time() > try_until:
                # If we reach this point, MAX_STARTUP_TIME has passed,
                # but we couldn't connect to the child, so we kill it.
                warn(str(err))
                for i in range(MAX_SHUTDOWN_TIME):
                    if i > 1:
                        time.sleep(i)
                    try:
                        os.kill(pid, signal.SIGTERM)
                    except OSError as err:
                        if err.errno == 3:
                            break
                else:
                    try:
                        os.kill(pid, signal.SIGKILL)
                    except OSError:
                        pass
                sys.exit(69)
    sys.exit()


# CHILD
# =====

# Deamonise!
os.chdir(data_dir)
os.setsid()
os.umask(0o077)
for stream, mode in ((sys.stdin, 'r'), (sys.stdout, 'a+'), (sys.stderr, 'a+')):
    stream.flush()
    fd = open(os.devnull, mode)
    os.dup2(fd.fileno(), stream.fileno())

# Create the PID file.
atexit.register(os.unlink, pid_fname)
with open(pid_fname, 'w') as pid_file:
    pid_file.write('{!s}\n'.format(os.getpid()))

# Prepare server.
socketserver.TCPServer.allow_reuse_address = True
handler = server.SimpleHTTPRequestHandler
httpd = socketserver.TCPServer(('localhost', args.port), handler)

# Shutdown on INT, QUIT or TERM.
for signo in (signal.SIGTERM, signal.SIGQUIT, signal.SIGINT):
    signal.signal(signo, httpd.shutdown)

httpd.serve_forever()
httpd.server_close()
