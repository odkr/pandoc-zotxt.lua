---
-- SYNOPSIS
-- ========
--
-- **pandoc** **-L** *pandoc-zotxt.lua* **-C**
--
-- DESCRIPTION
-- ===========
--
-- **pandoc-zotxt.lua** is a Lua filter for Pandoc that looks up citations in
-- Zotero and adds their bibliographic data to the "references" metadata field
-- or a bibliography file, where Pandoc can pick it up.
--
-- You cite your sources using so-called "Better BibTeX citation keys"
-- (provided by Better BibTeX for Zotero) or "Easy Citekeys" (provided by
-- zotxt) and then tell **pandoc** to filter your document through
-- **pandoc-zotxt.lua** before processing citations. That's all there is to it.
--
-- If the "references" metadata field or a bibliography file already contains
-- bibliographic data for a citation, that citation will be ignored.
--
-- CONNECTING TO ZOTERO
-- ====================
--
-- Desktop client
-- --------------
--
-- By default, bibliographic data is fetched from the Zotero desktop client,
-- which must be running when you invoke **pandoc**. This is the faster,
-- easier, and less error-prone method to lookup citations in Zotero. However,
-- you need to install the zotxt add-on for the Zotero desktop client to use
-- it.
--
-- Web API
-- -------
--
-- Bibliographic data can also be fetched from the Zotero Web API. If you want
-- to access your Zotero library via the Web API, you need to create a Zotero
-- API key and set the metadata field "zotero-api-key" to that key.
--
-- If you want to fetch bibliographic data from *public* Zotero groups, list
-- the IDs of those groups in the metadata field "zotero-public-groups".
-- Non-members must be allowed to access the libraries of these groups (this
-- is what makes them public). However, you do not need an API key to access
-- them.
--
-- The Zotero Web API does *not* allow to search for citation keys other than
-- Zotero item IDs. Therefore, BetterBibTeX citation keys and Easy Citekeys
-- have to be translated into search terms: Better BibTeX citation keys are
-- split up at the first of each series of digits and at uppercase letters
-- ("DoeTitle2020" becomes "Doe", "Title", "2020"). Easy Citekeys are split up
-- at the first colon and at the last digit ("doe:2020title" becomes "doe",
-- "2020", "title").
--
-- If a search yields more than one item, you need to add its citation key to
-- the item's "extra" field in Zotero to disambiguate it from the others.
-- Zotero's "extra" field is a list of CSL key-value pairs; keys and values
-- are separated by a colon and key-value pairs by a linefeed. Use the key
-- "Citation key" or the key "Citekey" to add a citation key (e.g., "Citation
-- key: DoeTitle2020"). Case is insignificant, spaces can be replaced by
-- dashes. If you use Better BibTeX for Zotero, you can add the citation key
-- it has generated by 'pinning' it. Alternatively, you can cite the source
-- using its Zotero item ID.
--
-- CACHING SOURCES WITH A BIBLIOGRAPHY FILE
-- ========================================
--
-- Bibliographic data can be added to a special bibliography file, rather than
-- to the "references" metadata field. This speeds up subsequent processing of
-- the same document, because that data need not be fetched again from Zotero.
--
-- To use such a bibliography file, set the "zotero-bibliography" metadata
-- field to a filename. If the filename is relative, it is interpreted as
-- relative to the directory of the first input file passed to **pandoc** or,
-- if no input file was given, as relative to the current working directory.
--
-- The format of the file is determined by its filename ending.
--
-- | **Ending** | **Format** |
-- | ---------- | ---------- |
-- | `.json`    | CSL JSON   |
-- | `.yaml`    | CSL YAML   |
--
-- The bibliography file is added to the "bibliography" metadata field
-- automatically. You can safely set "zotero-bibliography" and "bibliography"
-- at the same time.
--
-- Items are only added to the bibliography file, not updated or deleted. If
-- you need to update or delete an item, delete the bibliography file, so that
-- it will be regenerated from scratch.
--
-- CITATION KEY TYPES
-- ==================
--
-- You can use citation keys of multitple types:
--
-- | **Name**          | **Type**                   | **Example**   |
-- | ----------------- | -------------------------- | ------------- |
-- | `betterbibtexkey` | Better BibTeX citation key | DoeTitle2020  |
-- | `easykey`         | Easy Citekey               | doe:2020title |
-- | `key`             | Zotero item ID             | A1BC23D4      |
--
-- However, Better BibTeX citation keys are sometimes, if rarely,
-- misinterpreted as Easy Citekeys, which may cause the wrong item to be
-- fetched.
--
-- If this happens, disable Easy Citekeys by only listing BetterBibTeX
-- citation keys in the "zotero-citekey-types" metadata field:
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     ---
--     zotero-citekey-types: betterbibtexkey
--     ...
--     Forces @DoeTitle to be treated as BetterBibTeX citation key.
--     EOF
--
-- CONFIGURATION
-- =============
--
-- You can control how bibligraphic data is fetched by setting the following
-- metadata fields:
--
-- * `zotero-api-key`: A Zotero API key. Only applies to the Zotero Web API.
--
-- * `zotero-bibliography`: A bibliography filename. Fetched data is added to
-- this file.
--
-- * `zotero-citekey-types`: A list of citation key types. Citation keys are
-- treated as being of any of the listed types only.
--
-- * `zotero-connectors`: One or more Zotero connectors:
--
--   | **Key**   | **Fetch data from**   |
--   | --------- | --------------------- |
--   | zotxt     | Zotero desktop client |
--   | zoteroweb | Zotero Web API        |
--
--   Data is fetched via the listed connectors only.
--
--   By default, the Zotero desktop client is searched first. If you have set
--   a Zotero API key and if the client could not be reached or some citations
--   could not be found, the Zotero Web API is searched next.
--
-- * `zotero-groups`: A list of Zotero group IDs. Only the given groups are
-- searched. By default, all groups you are a member of are searched. Only
-- applies to the Zotero Web API.
--
-- * `zotero-public-groups`: A list of Zotero group IDs. The given groups are
-- searched in addition to non-public groups. Groups must be public. Only
-- applies to the Zotero Web API.
--
-- * `zotero-user-id`: A Zotero user ID. Looked up automatically if not given.
-- Only applies to the Zotero Web API.
--
-- If a metadata field takes a list of values, but you only want to give one,
-- you can enter that value as a scalar.
--
-- EXAMPLES
-- ========
--
-- Look up "DoeTitle2020" in Zotero:
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     See @doe2020Title for details.
--     EOF
--
-- Add bibliographic data to the file "bibliography.json":
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     ---
--     zotero-bibliography: bibliography.json
--     ...
--     See @DoeTitle2020 for details.
--     EOF
--
-- Interpret "doe:2020title" as a Better BibTeX citation key:
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     ---
--     zotero-citekey-types: betterbibtexkey
--     ...
--     See @doe:2020title for details.
--     EOF
--
-- Fetch data from the Zotero Web API, too:
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     ---
--     zotero-api-key: MO2GHxbkLnWgCqPtpoewgwIl
--     ...
--     See @DoeTitle2020 for details.
--     EOF
--
-- Fetch data from the Zotero Web API *only*:
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     ---
--     zotero-api-key: MO2GHxbkLnWgCqPtpoewgwIl
--     zotero-connectors: zoteroweb
--     ...
--     See @DoeTitle2020 for details.
--     EOF
--
-- KNOWN ISSUES
-- ============
--
-- A citation key may pick out the wrong item if it picks out a different
-- items depending on whether it is interpreted as a Better BibTeX citation
-- key or as an Easy Citekey. Set the 'zotero-citekey-types' metadata field to
-- fix this.
--
-- **pandoc-zotxt.lua** creates a temporary file when it adds bibliographic
-- data to a bibliography file. If Pandoc exits because it catches a signal
-- (e.g., because you press `Ctrl`-`c`), then this file will *not* be deleted.
-- This is a bug in Pandoc (issue #7355) and in the process of being fixed.
-- Moreover, if you are using Pandoc up to v2.7, another process may,
-- mistakenly, use the same temporary file at the same time, though this is
-- highly unlikely.
--
-- Zotero v5.0.71 and v5.0.72 fail to handle HTTP requests from user agents
-- that do not set the "User Agent" HTTP header. And **pandoc** does not. As a
-- consequence, **pandoc-zotxt.lua** cannot retrieve data from these versions
-- of Zotero unless you tell **pandoc** to set that header.
--
-- Support for accessing group libraries via the Zotero Web API is limited.
-- They are only searched if no item in your personal library matches. Also,
-- the "extra" field of items in group libraries is ignored.
--
-- SECURITY
-- ========
--
-- If you are using Pandoc up to v2.7 and place the auto-generated
-- bibliography file in a directory that other users have write access to,
-- then they can read and change the content of that file, regardless of
-- whether they have permission to read or write the file itself.
--
-- CAVEATS
-- =======
--
-- **pandoc-zotxt.lua** is Unicode-agnostic.
--
-- SEE ALSO
-- ========
--
-- * [zotxt](https://github.com/egh/zotxt)
-- * [Better BibTeX](https://retorque.re/zotero-better-bibtex/)
--
-- pandoc(1)
--
-- @script pandoc-zotxt.lua
-- @release 1.1.0
-- @author Odin Kroeger
-- @copyright 2018, 2019, 2020, 2021, 2022 Odin Kroeger
-- @license MIT

-- Table of Contents
--------------------

--- Metadata
-- @section Metadata

--- Operating system
-- @section

--- Types
-- @section

--- Variables
-- @section

--- Tables
-- @section

--- Strings
-- @section

--- Prototypes
-- @section

--- Errors
-- @section

--- File I/O
-- @section

--- Networking
-- @section

--- Markup converters
-- @section

--- CSL items.
--
-- [Appendix IV](https://perma.cc/7LPL-F4XD) of the Citation Style Language
-- (CSL) specification lists all CSL variable names.
--
-- @section

--- Citation keys
-- @section

--- Bibliography files
-- @section

--- Document parsing
-- @section

--- Option parsing
-- @section

--- Zotero connectors
-- @section

--- Main
-- @section

-- Initialisation
-----------------

-- luacheck: allow defined top
-- luacheck: ignore path_prettify

-- Run in debugging mode?
-- luacheck: push ignore DEBUG
local DEBUG = DEBUG or false
-- luacheck: pop

-- Built-in functions.
local assert = assert
local error = error
local getmetatable = getmetatable
local next = next
local pairs = pairs
local pcall = pcall
local rawset = rawset
local require = require
local select = select
local setmetatable = setmetatable
local tonumber = tonumber
local tostring = tostring
local type = type
local xpcall = xpcall

-- Modules.
local debug = debug
local io = io
local math = math
local os = os
local package = package
local string = string
local table = table
local utf8 = utf8

-- Pandoc.
-- luacheck: push ignore
local pandoc = pandoc
if not pandoc.utils then pandoc.utils = require 'pandoc.utils' end

if pandoc.types then
    if PANDOC_VERSION >= {2, 8} and not pandoc.system then
        pandoc.system = require 'pandoc.system'
    end
    if PANDOC_VERSION >= {2, 12} and not pandoc.path then
        pandoc.path = require 'pandoc.path'
    end
end

local PANDOC_STATE = PANDOC_STATE
local PANDOC_SCRIPT_FILE = PANDOC_SCRIPT_FILE
local PANDOC_VERSION = PANDOC_VERSION
-- luacheck: pop

local M = {}
local _ENV = M

-- Shorthands.
local format = string.format
local concat = table.concat
local pack = table.pack
local unpack = table.unpack
local sort = table.sort

local read = pandoc.read
local stringify = pandoc.utils.stringify

local List = pandoc.List
local MetaInlines = pandoc.MetaInlines
local MetaList = pandoc.MetaList
local MetaMap = pandoc.MetaMap
local Str = pandoc.Str
local Span = pandoc.Span
local Pandoc = pandoc.Pandoc


--------
-- Types
--
-- @section

do
    local abbrs = {
        ['%*'] = 'boolean|function|number|string|table|thread|userdata',
        ['%?(.*)'] = '%1|nil'
    }

    --- Check whether a value is of a type.
    --
    -- <h3>Type declaration grammar:</h3>
    --
    -- Declare one or more Lua type names separated by '|' to require that
    -- the given value to be of one of the given types (e.g., `'string|table'`
    -- requires the value to be a string or a table). `'*'` is short for the
    -- list of all types but `nil`. `'?T'` is short for `'T|nil'` (e.g.,
    -- `'?table'` is short for `'table|nil'`).
    --
    -- In [Extended Backus-Naur Form](https://en.wikipedia.org/wiki/EBNF):
    --
    -- > Type = 'boolean' | 'function' | 'nil'    | 'number'   |
    -- >        'string'  | 'table'    | 'thread' | 'userdata'
    -- >
    -- > Type list = [ '?' ], ( '*' | type, { '|', type list } )
    --
    -- <h3>Complex types:</h3>
    --
    -- Check types of table or userdata fields by declaring
    -- a table that maps indices to type declarations.
    --
    --    > type_check({1, '2'}, {'number', 'number'})
    --    nil    index 2: expected number, got string.
    --    > type_check({foo = 'bar'}, {foo = '?table'})
    --    nil    index foo: expected table or nil, got string.
    --    > type_check('foo', {foo = '?table'})
    --    nil    expected table or userdata, got string.
    --
    -- @caveats Non-referring type names (e.g., 'int') do *not* raise an error,
    --  they just fail for any given value.
    --
    -- @param val A value.
    -- @tparam string|table td A type declaration.
    -- @treturn[1] bool `true` if the value is of the declared type(s).
    -- @treturn[2] nil `nil` otherwise.
    -- @treturn[2] string An error message.
    -- @raise An error if the type declaration is malformed.
    function type_match (val, td, _seen)
        local dt = type(td)
        if dt == 'string' then
            for pat, repl in pairs(abbrs) do td = td:gsub(pat, repl) end
            assert(td:match '^([%l|]+)$', 'malformed type declaration.')
            local t = type(val)
            for ex in td:gmatch '[^|]+' do if t == ex then return true end end
            local err = format('expected %s, got %s.', td:gsub('|', ' or '), t)
            return nil, err
        elseif dt == 'table' then
            local ok, err = type_match(val, 'table|userdata')
            if not ok then return nil, err end
            if not _seen then _seen = {} end
            assert(not _seen[val], 'cycle in data tree.')
            _seen[val] = true
            for k, t in pairs(td) do
                ok, err = type_match(val[k], t, _seen)
                if not ok then return nil, format('index %s: %s', k, err) end
            end
            return true
        end
        error(format('expected string or table, got %s.', dt))
    end
end

--- Type-check function arguments in debugging mode.
--
-- <h3>Type declaration grammar:</h3>
--
-- The type declaration syntax is that of @{type_match}, save for that `'...'`
-- can be used to require that an argument is of the same type as the previous
-- one. If `'...'` is the last type declaration, the previous declaration
-- applies to all remaining arguments.
--
-- @tip If you get obscure Lua errors after you have added type checks to
--  a function, you may have forgotten the quotes around '`...`'.
--
-- @caveats Non-referring type names (e.g., 'int') do *not* raise an error
--  at compile-time, they just fail at run-time.
--
-- @tparam string|table ... Type declarations. See @{type_match}.
-- @treturn func A function that adds type checks to a function.
--
-- @usage
-- copy = typed_args('?*', '?table')(
--     function (val, _seen)
--         if type(val) ~= 'table' then return val end
--         if     not _seen  then _seen = {}
--         elseif _seen[val] then return _seen[val]
--         end
--         local ret = setmetatable({}, getmetatable(val))
--         _seen[val] = ret
--         for k, v in next, val do
--             rawset(ret, copy(k, _seen), copy(v, _seen))
--         end
--         return ret
--     end
-- )
--
-- @function typed_args
function typed_args (...)
    local decls = pack(...)
    return function (func)
        return function (...)
            -- luacheck: ignore type
            local args = pack(...)
            local td, prev
            local n = math.max(decls.n, args.n)
            for i = 1, n do
                if     decls[i] == '...' then prev = true
                elseif decls[i]          then prev = false
                                              td = decls[i]
                elseif not prev          then break
                end
                if args[i] == nil and prev and i == n then break end
                local ok, err = type_match(args[i], td)
                if not ok then error(format('argument %d: %s', i, err), 2) end
            end
            return func(...)
        end
    end
end

if not DEBUG then
    function typed_args ()
        return function (...) return ... end
    end
end


-------------------
-- Operating system
--
-- @section

--- The path segment separator used by the operating system.
PATH_SEP = package.config:sub(1, 1)

--- The end of line sequence used on the given operating system.
EOL = '\n'
if PATH_SEP == '\\' then EOL = '\r\n' end

--- What type of operating system is the script running under?
OS_TYPE = 'POSIX'
if PATH_SEP == '\\' then OS_TYPE = 'Windows' end


-----------
-- File I/O
--
-- @section

--- Join multiple path segments.
--
-- @caveats Accepts empty strings as arguments.
--
-- @string ... Path segments.
-- @treturn string A path.
--
-- @function path_join
path_join = typed_args('string', '...')(
    function (...)
        return path_normalise(concat({...}, PATH_SEP))
    end
)

do
    -- Patterns that normalise directory paths.
    -- The order of these patterns is significant.
    local patterns = {
        -- Replace '/./' with '/'.
        {PATH_SEP .. '%.' .. PATH_SEP, PATH_SEP},
        -- Replace a sequence of '/'s with a single '/'.
        {PATH_SEP .. '+', PATH_SEP},
        -- Remove trailing '/'s, but not for the root node.
        {'(.)' .. PATH_SEP .. '$', '%1'},
        -- Remove './' at the beginning of a path.
        {'^%.' .. PATH_SEP, ''}
    }

    --- Normalise a path.
    --
    -- @string path A path.
    -- @treturn string A normalised path.
    --
    -- @function path_normalise
    path_normalise = typed_args('string')(
        function (path)
            assert(path ~= '', 'path is the empty string.')
            for i = 1, #patterns do path = path:gsub(unpack(patterns[i])) end
            return path
        end
    )
end

do
    -- Pattern to split a path into a directory and a filename part.
    local pattern = '(.-' .. PATH_SEP .. '?)([^' .. PATH_SEP .. ']-)$'

    --- Split a path into a directory and a filename.
    --
    -- @string path A path.
    -- @treturn string The directory the file is in.
    -- @treturn string The file's name.
    --
    -- @function path_split
    path_split = typed_args('string')(
        function (path)
            assert(path ~= '', 'path is the empty string.')
            local dir, fname = path:match(pattern)
            if     dir == ''   then dir = '.'
            elseif fname == '' then fname = '.'
            end
            return path_normalise(dir), fname
        end
    )
end


-----------
-- Metadata
--
-- @section

--- The name of this script.
NAME = 'pandoc-zotxt.lua'

--- The version of this script.
VERSION = '1.1.0'

do
    local script_dir, script_name = path_split(PANDOC_SCRIPT_FILE)

    --- The directory the script is located in.
    SCRIPT_DIR = script_dir

    --- The filename of the script.
    SCRIPT_NAME = script_name
end

do
    local repo = NAME .. '-' .. VERSION
    local sub_dir = path_join('share', 'lua', '5.4', '?.lua')
    package.path = concat({package.path,
        path_join(SCRIPT_DIR, sub_dir),
        path_join(SCRIPT_DIR, repo, sub_dir)
    }, ';')
end

local json = require 'lunajson'


------------
-- Variables
--
-- @section

--- Get a copy of the variables of a function and of `_ENV`.
--
-- @caveats
--
-- If a global variable is shadowed by a variable that is neither one of the
-- function's local variables nor one of its upvalues, then the value
-- from `_ENV` is returned, *not* the shadowed one.
--
-- @int[opt=2] level A stack level, where
--
--  * 1 = `vars_get`,
--  * 2 = the function calling `vars_get`,
--  * ⋮
--  * *n* = the function calling the function at level *n* – 1.
--
-- @treturn[1] table A mapping of variable names to values.
-- @treturn[2] nil `nil` if there is no function at that level of the stack.
-- @treturn[2] string An error message.
--
-- @usage
-- > function bar ()
-- >     print(vars_get(3).foo)
-- > end
-- > function foo ()
-- >     foo = 'foo'
-- >     bar()
-- > end
-- > foo()
-- foo
--
-- @function vars_get
vars_get = typed_args('?number')(
    function (level)
        if not level then level = 2 end
        assert(level > 0, 'level is not a positive number.')
        local info = debug.getinfo(level, 'f')
        if not info then return nil, tostring(level) .. ': no such level.' end
        local vars = copy(_ENV)
        for i = 1, 2 do
            local iter, arg
            if     i == 1 then iter, arg = debug.getupvalue, info.func
            elseif i == 2 then iter, arg = debug.getlocal, level
            end
            local j = 1
            while true do
                local k, v = iter(arg, j)
                if not k then break end
                vars[k] = copy(v)
                j = j + 1
            end
        end
        return vars
    end
)


---------
-- Tables
--
-- @section

---
-- Sets are tables that map items to boolean values.
-- If `set[item]` is `true`, `item` is a member of `set`.
--
-- See *Progamming in Lua* ([chap. 11.5](https://www.lua.org/pil/11.5.html)).
--
-- @caveats This table exists in documentation only.
-- @table Set

--- Metatable to make index lookups case-insensitive.
--
-- @usage
--
-- > tab = setmetatable({}, ignore_case)
-- > tab.FOO = 'bar'
-- > tab.foo
-- bar
ignore_case = {}

--- Look up an item.
--
-- @tab tab A table.
-- @param key A key.
-- @return The item.
function ignore_case.__index (tab, key)
    if type(key) == 'string' and key:match '%u' then
        return tab[key:lower()]
    end
end

--- Store a new item.
--
-- @tab tab A table.
-- @param key A key.
-- @param val A value.
function ignore_case.__newindex (tab, key, val)
    if type(key) == 'string' then rawset(tab, key:lower(), val)
                             else rawset(tab, key, val)
    end
end

do
    -- Make a deep copy of a value.
    --
    -- @caveats Bypasses metamethods.
    --
    -- @param val A value.
    -- @return A deep copy.
    --
    -- @usage
    -- > foo = {1, 2, 3}
    -- > bar = {foo, 4}
    -- > baz = copy_deep(bar)
    -- > foo[#foo + 1] = 4
    -- > table.unpack(baz, 1)
    -- 1    2    3
    --
    -- @function copy_deep
    local function copy_deep (val, _seen)
        -- Borrows from:
        -- * <https://gist.github.com/tylerneylon/81333721109155b2d244>
        -- * <http://lua-users.org/wiki/CopyTable>
        if type(val) ~= 'table' then return val end
        if     not _seen  then _seen = {}
        elseif _seen[val] then return _seen[val]
        end
        local ret = setmetatable({}, getmetatable(val))
        _seen[val] = ret
        for k, v in next, val do
            rawset(ret, copy_deep(k, _seen), copy_deep(v, _seen))
        end
        return ret
    end

    -- Make a shallow copy of a value.
    --
    -- @caveats Bypasses metamethods.
    --
    -- @param val A value.
    -- @return A shallow copy.
    --
    -- @usage
    -- > foo = {1, 2, 3}
    -- > bar = {foo, 4}
    -- > baz = copy_shallow(bar)
    -- > foo[#foo + 1] = 4
    -- > table.unpack(baz, 1)
    -- 1    2    3    4
    --
    -- @function copy_shallow
    local function copy_shallow (val)
        if type(val) ~= 'table' then return val end
        local ret = setmetatable({}, getmetatable(val))
        for k, v in next, val do rawset(ret, k, v) end
        return ret
    end

    --- Copy a value.
    --
    -- @caveats Bypasses metamethods.
    --
    -- @param val A value.
    -- @bool[opt=true] deep Make a deep copy?
    -- @return A copy.
    --
    -- @usage
    -- > foo = {1, 2, 3}
    -- > bar = {foo, 4}
    -- > baz = copy(bar)
    -- > foo[#foo + 1] = 4
    -- > table.unpack(baz, 1)
    -- 1    2    3
    --
    -- @function copy
    copy = typed_args('?*', '?boolean')(
        function (val, deep)
            if deep == false then return copy_shallow(val) end
            return copy_deep(val)
        end
    )
end

--- Get the keys and the number of items in a table.
--
-- @tab tab A table.
-- @treturn tab The keys of the table.
-- @treturn int The number of items in the table.
--
-- @function keys
keys = typed_args('table')(
    function (tab)
        local ks = {}
        local n = 0
        for k in pairs(tab) do
            n = n + 1
            ks[n] = k
        end
        return ks, n
    end
)

--- Define a sorting function from a list of values.
--
-- @tab values Values.
-- @treturn func A sorting function.
--
-- @usage
-- > tab = {a = 3, b = 4, c = 2, d = 1}
-- > for k, v in sorted(tab, order{'d', 'c'}) do
-- >     print(k, v)
-- > end
-- d    1
-- c    2
-- a    3
-- b    4
--
-- @function order
order = typed_args('table')(
    function (vals)
        local order = {}
        for i = 1, #vals do order[vals[i]] = i end
        return function (a, b)
            local i, j = order[a], order[b]
            if i and j then return i < j end
            if i then return true end
            if j then return false end
            return a < b
        end
    end
)

--- Iterate over the key-value pairs of a table in a given order.
--
-- @tab tab A table.
-- @func[opt] func A sorting function.
--  If no function is given, sorts lexically.
-- @treturn func A *stateful* iterator.
--
-- @usage
-- > for k, v in sorted{c = 3, b = 2, a = 1} do
-- >     print(k, v)
-- > end
-- a    1
-- b    2
-- c    3
--
-- @function sorted
sorted = typed_args('table', '?function')(
    function (tab, func)
        local ks = keys(tab)
        sort(ks, func)
        local n = 0
        local function iter ()
            n = n + 1
            local k = ks[n]
            if k == nil then return end
            return k, tab[k]
        end
        return iter, tab
    end
)

--- Tabulate the values an iterator returns.
--
-- The iterator must accept the same arguments as @{next}.
--
-- @func iter An iterator.
-- @param[opt] tab A table to iterate over.
-- @param[opt] key The index to start iterating at.
-- @return The values returned by the iterator.
--
-- @usage
-- > str = 'key: value'
-- > k, v = tabulate(split(str, '%s*:%s*', 2))
-- > print(k, v)
-- key    value
--
-- @function tabulate
-- @fixme Stateless iterators are not unit-tested.
tabulate = typed_args('function')(
    function (iter, tab, key)
        local vals = Values()
        for v in iter, tab, key do vals:add(v) end
        return unpack(vals)
    end
)

--- Merge tables.
--
-- @caveats Updates the first table *in-place*.
--
-- @tab ... Tables.
-- @treturn tab The first table.
--
-- @function update
update = typed_args('table', '?table', '...')(
    function (...)
        local tabs = pack(...)
        local tab = tabs[1]
        for i = 2, tabs.n do
            if tabs[i] then
                for k, v in pairs(tabs[i]) do tab[k] = v end
            end
        end
        return tab
    end
)

--- Walk a tree and apply a function to every node.
--
-- A node is only changed if the function does *not* return `nil`.
--
-- @param val A value.
-- @func func A function.
-- @return The transformed tree.
--
-- @function walk
walk = typed_args('*', 'function', '?table')(
    function (val, func, _seen)
        if type(val) ~= 'table' and type(val) ~= 'userdata' then
            local ret = func(val)
            if ret == nil then return val end
            return ret
        end
        if     not _seen  then _seen = {}
        elseif _seen[val] then return _seen[val]
        end
        local ret = {}
        _seen[val] = ret
        for k, v in pairs(val) do
            if type(v) == 'table' then v = walk(v, func, _seen) end
            local new = func(v)
            if new == nil then ret[k] = v
                          else ret[k] = new
            end
        end
        return ret
    end
)


----------
-- Strings
--
-- @section

--- Iterate over substrings of a string.
--
-- @caveats Supports neither multi-byte characters nor frontier patterns.
--
-- @string str A string.
-- @string pattern Where to split the string.
-- @int[opt] max Split the string into at most that many substrings.
-- @string[opt] include Include separators in substrings?
--
--  * `l` includes separators on the left,
--  * `r` on the right.
--
--  By default, separators are *not* included.
-- @treturn func A *stateful* iterator.
--
-- @usage
-- > for s in split('CamelCase', '%u', nil, 'l') do
-- >     print(string.format("%s", s))
-- > end
-- ""
-- "Camel"
-- "Case"
--
-- @function split
split = typed_args('string', 'string', '?number', '?string')(
    function (str, pattern, max, include)
        assert(not pattern:match '%f[%%]%%f', 'split does not support %f.')
        assert(not include or include:match '^[lr]$', 'expecting "l" or "r".')
        local pos = 1
        local n = 0
        local i, j
        return function ()
            local sep, last
            if not pos then return end
            if include == 'l' and i then sep = str:sub(i, j) end
            i = nil
            j = nil
            n = n + 1
            if n == max then
                last = -1
            else
                i, j = str:find(pattern, pos)
                if     not i          then last = -1
                elseif include == 'r' then last = j
                                      else last = i - 1
                end
            end
            local sub = str:sub(pos, last)
            if sep then sub = sep .. sub end
            if j then pos = j + 1
                 else pos = nil
            end
            return sub
        end
    end
)

--- Remove leading and trailing whitespace.
--
-- @string str A string.
-- @treturn string A trimmed string.
--
-- @function trim
trim = typed_args('string')(
    function (str)
        return str:gsub('^%s+', ''):gsub('%s*$', ''), nil
    end
)

do
    -- Lookup a path in a namespace.
    --
    -- @tab vars A mapping of variable names to values.
    -- @string path A path. Seperate segments by dots.
    -- @return A value.
    local function lookup (vars, path)
        local v = vars
        for n in split(path, '%.') do
            if n == '' then break end
            v = v[n]
        end
        return v
    end

    -- Expand a variable from a variable expression.
    --
    -- See @{vars_sub} for the expression syntax.
    --
    -- @tparam Set seen The variables encounterd so far.
    -- @tab vars A mapping of variable names to values.
    -- @string exp A variable expression.
    -- @treturn string The value of the expression.
    -- @raise See @{vars_sub}.
    local function evaluate (seen, vars, exp)
        local path, func = tabulate(split(exp:sub(2, -2), '|', 2))
        assert(not seen[path], 'cycle in variable lookup.')
        seen[path] = true
        local v = lookup(vars, path)
        if type(v) == 'string' then v = vars_sub(v, vars, seen) end
        if func then v = lookup(vars, func)(v) end
        return vars_sub(tostring(v), vars, seen)
    end

    --- Substitute variables in strings.
    --
    -- If a string of characters is placed within braces ('{...}') and the
    -- opening brace ('{') immediately follows a single dollar ('$') sign,
    -- then that string is treated as a variable name and the whole
    -- expression is replaced with the value of that variable.
    --
    --    > vars_sub(
    --    >     '${v1} is ${v2}.',
    --    >     {v1 = 'foo', v2 = 'bar'}
    --    > )
    --    foo is bar.
    --
    -- If a braced string is preceded by two or more dollar signs, it is *not*
    -- *not* treated as a variable name and *not* replaced. Any series of *n*
    -- dollar signs is replaced with *n* – 1 dollar signs.
    --
    --    > vars_sub(
    --    >     '$${var} costs $$1.',
    --    >     {var = 'foo'}
    --    > )
    --    ${var} costs $1.
    --
    -- If a variable name is followed by a pipe symbol ('|'), then the string
    -- of characters between the pipe symbol and the closing brace ('}') is
    -- treated as a function name; the value of the variable is then passed to
    -- that function, and the whole expression `${<variable>|<function>}` is
    -- replaced with the first value that this function returns. Variable
    -- names cannot contain the pipe symbol, but function names may.
    --
    --    > vars_sub(
    --    >     '${var|barify} is bar!', {
    --    >         var = 'foo',
    --    >         barify = function (s)
    --    >             return s:gsub('foo', 'bar')
    --    >         end
    --    >     }
    --    > )
    --    bar is bar!
    --
    -- You can lookup values in tables by joining the name of the variable
    -- and that of the table index with a dot ('.'). Neither variable nor
    -- function names can contain dots.
    --
    --    > vars_sub(
    --    >     '${foo.bar} is baz.', {
    --    >         foo = { bar = 'baz' }
    --    >     }
    --    > )
    --    baz is baz.
    --
    -- Expressions are evaluated recursively.
    --
    --    > vars_sub(
    --    >     '${foo|barify} is bar.', {
    --    >         foo = '${bar}',
    --    >         bar = 'baz'
    --    >         barify = function (s) return s:gsub('baz', 'bar') end
    --    >     }
    --    > )
    --    bar is bar.
    --
    -- @caveats
    --
    -- * If there is no variable of a given name,
    --   the expression is quietly replaced with `nil`.
    --
    --       > vars_sub('foo is ${bar}.', {})
    --       foo is nil.
    --
    -- * The empty string is a valid variable name.
    --
    --       > vars_sub('foo is ${}.', {[''] = bar})
    --       foo is bar.
    --
    -- * Error messages are cryptic.
    --
    -- @string str A string.
    -- @tab vars Variables.
    -- @treturn string A transformed string.
    --
    -- @function vars_sub
    -- @todo Improve error messages.
    vars_sub = typed_args('string', 'table', '?table')(
        function (str, vars, _seen)
            if not _seen then _seen = {} end
            local function eval (...) return evaluate(_seen, vars, ...) end
            return str:gsub('%f[%$]%$(%b{})', eval):gsub('%$(%$*)', '%1'), nil
        end
    )
end


-------------
-- Prototypes
--
-- @section

--- Base prototype.
--
-- @object Object
Object = {}

--- Metatable for prototypes.
Object.mt = {}
setmetatable(Object, Object.mt)

--- Delegate to a prototype.
--
-- Create a new table, set its metatable to a copy of the prototype's
-- metatable, set the `__index` metavalue to the prototype, and merge
-- its metatable with the given metatable, in that order.
--
-- That is,
--
--    obj = Object(mt)
--
-- is short for
--
--    do
--        local mt = update({}, getmetatable(Object), {__index = Object}, mt)
--        obj = setmetatable({}, mt)
--    end
--
-- @tab proto A prototype.
-- @tab[opt] mt A metatable.
-- @treturn Object An object.
--
-- @usage
-- > Foo = Object{__tostring = function (t) return t.bar end}
-- > Foo.bar = 'bar'
-- > tostring(foo)
-- > bar = Foo()
-- > tostring(bar)
-- bar
-- > bar.bar = 'baz'
-- > tostring(bar)
-- baz
--
-- @function Object.mt.__call
Object.mt.__call = typed_args('table', '?table')(
    function (proto, mt)
        return setmetatable({}, update(
            {}, getmetatable(proto), {__index = proto}, mt)
        )
    end
)

--- Initialise a new object.
--
-- `Object:new(props)` is short for `update(Object(), props)`.
--
-- @tab proto A prototype.
-- @tab[opt] props Properties.
-- @treturn Object An object.
--
-- @usage
-- > foo = Object:new{foo = 'foo'}
-- > foo.foo
-- foo
--
-- @function Object:new
Object.new = typed_args('table', '?table')(
    function (proto, props)
        return update(proto(), props)
    end
)

--- A simple list.
--
-- @tip
--
-- You can sparse-copy a list by using it as a prototype:
--
--    > foo = Values:new 'foo'
--    > bar = foo()
--    > bar:add 'bar'
--    > #bar
--    2
--    > for i, v in ipairs(bar) do
--    >     print(i, v)
--    > end
--    1    foo
--    2    bar
--
-- @usage
-- > list = Values()
-- > list:add 'a string'
-- > list.n
-- 1
--
-- @object Values
-- @proto @{Object}
Values = Object()

--- Metatable for values.
Values.mt = getmetatable(Values)

--- Get the size of the list.
--
-- @tparam Values obj A list.
-- @treturn number The size of the list.
function Values.mt.__len (obj)
    return obj.n
end

--- Iterate over list items.
--
-- @tparam Values obj A list.
-- @treturn function A stateless iterator.
function Values.mt.__pairs (obj)
    return function (tab, idx)
        if not idx then idx = 1
                   else idx = idx + 1
        end
        if idx > tab.n then return end
        return idx, tab[idx]
    end, obj
end

--- The number of items in the list.
Values.n = 0

--- Create a new list.
--
--    list = Values:new(foo, bar)
--
-- is equivalent to:
--
--    list = Values()
--    list:add(foo, bar)
--
-- @tip
--
-- You can convert an ordinary table to a `Values` object by:
--
--    tab.n = #tab
--    setmetatable(tab, getmetatable(Values))
--
-- @param ... Items.
--
-- @function Values:new
Values.new = typed_args({add = 'function'})(
    function (proto, ...)
        local obj = Object.new(proto)
        if select('#', ...) > 0 then obj:add(...) end
        return obj
    end
)

--- Add items to the list.
--
-- @side Sets @{Values.n} to the number of items in the list.
--
-- @param ... Items.
--
-- @function Values:add
Values.add = typed_args({n = 'number'})(
    function (self, ...)
        local items = pack(...)
        local n = self.n
        for i = 1, items.n do self[n + i] = items[i] end
        self.n = n + items.n
    end
)

--- Add getters to a table.
--
-- <h3>Getter protocol:</h3>
--
-- If an index is not present in a the table, look for a function of the same
-- name in the table's `getters` metavalue. That metavalue must be a mapping
-- of indices to functions. If it contains a function of that name, then that
-- function is called with the table as its only argument and whatever it
-- returns is returned as the value of the given index. If `getters` contains
-- no function of that name, the name is looked up in the table's *old*
-- `__index` metavalue.
--
-- @caveats
--
-- * Tables are modified *in-place*.
-- * Getters are *not* inherited.
--
-- @tab tab A table.
-- @treturn tab The table.
--
-- @usage
-- > -- Enable getters for an object.
-- > foo = getterify(Object())
-- > foo.foo = 'bar'
-- > mt = getmetatable(foo)
-- > mt.getters = {}
-- > function mt.getters.bar () return self.foo end
-- > foo.bar
-- bar
-- > -- The getter is reached via the prototype chain,
-- > -- so it sees foo.foo, not bar.foo:
-- > baz = foo()
-- > baz.foo = 'bam!'
-- > baz.bar
-- bar
-- > -- But you can make getters quasi-inheritable:
-- > mt.__call = delegate_with_getters
-- > baz = foo()
-- > baz.foo = 'bam!'
-- > baz.bar
-- bam!
--
-- @function getterify
-- @fixme Not unit-tested.
getterify = typed_args('table')(
    function (tab)
        local mt = copy(getmetatable(tab))
        local index = mt.__index
        mt.__index = typed_args('table')(
            -- luacheck: ignore tab
            function (tab, key)
                local getters = getmetatable(tab).getters
                if getters then
                    local get = getters[key]
                    if get then return get(tab) end
                end
                if index then
                    local t = type(index)
                    if t == 'table'    then return index[key]      end
                    if t == 'function' then return index(tab, key) end
                    local err = 'table\'s "__index" metavalue points to a %s.'
                    error(err:format(t), 2)
                end
            end
        )
        return setmetatable(tab, mt)
    end
)

--- Delegate to a prototype and add getters.
--
-- `delegate_with_getters(obj, mt)` is short for
-- `getterify(getmetatable(Object).__call(obj, mt))`.
--
-- @tab proto A prototype.
-- @tab[opt] tab A table.
-- @treturn Object A getterified table.
--
-- @see getterify
-- @function delegate_with_getters
delegate_with_getters = typed_args('table', '?table')(
    function (...)
        return getterify(getmetatable(Object).__call(...))
    end
)


---------
-- Errors
--
-- @section

--- A prototype for errors.
--
-- @object Error
-- @proto Object
-- @see xerror
-- @see xassert
Error = Object()

--- Metatable for errors.
Error.mt = getmetatable(Error)

--- Convert error objects to strings.
--
-- Take @{Error.mt.template}, replace variables with the properties of the
-- same names and return the result. See @{vars_sub} for the variable
-- substitution syntax.
--
-- @tab tab An error object.
-- @treturn string An error message.
--
-- @usage
-- > SomeError = Error{template = 'Something went ${severity} wrong!'}
-- > err = SomeError:new{severity = 'slightly'}
-- > tostring(err)
-- Something went slightly wrong!
--
-- @fixme Not unit-tested.
function Error.mt.__tostring (tab)
    local mt = getmetatable(tab)
    return vars_sub(mt.template, tab)
end

--- A default template for error messages.
Error.mt.template = 'something went wrong.'

do
    -- Priority levels for messages.
    local levels = List{'error', 'warning', 'info'}

    -- What level if verbosity is desired.
    local verbosity = PANDOC_STATE.verbosity:lower()

    --- Write strings to STDERR.
    --
    -- @param ... Strings to write to STDERR.
    local function write (...) io.stderr:write(...) end

    --- Compare verbosity levels.
    --
    -- @string a A verbosity level.
    -- @string b Another verbosity level.
    -- @treturn bool Whether level A is smaller than level B.
    local verbosity_lt = order(levels)

    --- Print a message to STDERR.
    --
    -- <h3>Printout:</h3>
    --
    -- The message is prefixed with `SCRIPT_NAME .. ': '` and terminated
    -- with @{EOL}. Non-string values are coerced to strings.
    --
    -- <h3>Message priority:</h3>
    --
    -- Messages are only printed if their priority is equal to or greater than
    -- `PANDOC_STATE.verbostiy`, where 'error' > 'warning' > 'info'.
    --
    -- <h3>Variable substitution:</h3>
    --
    -- If string values contain variable names, they are replaced with the
    -- values of the local variables or the upvalues of the calling function
    -- or, if there are no local variables or upvalues of the given names,
    -- with values of the global variables of the module. See @{vars_sub} for
    -- the syntax and @{vars_get} for limitationss.
    --
    -- <h3>Options:</h3>
    --
    -- String values that start with an '@' are interpreted as options:
    --
    -- * `'@error'`, `'@warning'`, `'@info'`: Set the message's
    --   priority. (*default* 'warning')
    -- * `'@novars'`: Turn variable substitution off. (*default* on)
    -- * `'@vars'`: Turn variable substitution on.
    -- * `'@noopts'`: Turn option processing off. (*default* on)
    -- * `'@plain'`: Turn variable substitution *and* option processing off.
    --
    -- Unknown options are ignored.
    --
    -- @param ... Messages. At least one must be given.
    --
    -- @function xwarn
    xwarn = typed_args('*')(
        function (...)
            local priority = 'warning'
            local do_opts_get = true
            local do_vars_sub = true
            local vars
            local function opts_get (msg)
                if not do_opts_get or msg:sub(1, 1) ~= '@' then return end
                local opt = msg:sub(2)
                if     levels:includes(opt) then priority = opt
                elseif opt == 'vars'        then do_vars_sub = true
                elseif opt == 'novars'      then do_vars_sub = false
                elseif opt == 'noopts'      then do_opts_get = false
                elseif opt == 'plain'       then do_vars_sub = false
                                                 do_opts_get = false
                end
                return true
            end
            local msgs = pack(...)
            local i = 1
            while i <= msgs.n do
                local msg = msgs[i]
                if
                    type(msg) ~= 'string' or
                    not opts_get(msg)
                then break end
                i = i + 1
            end
            if i > msgs.n or verbosity_lt(verbosity, priority) then return end
            write(SCRIPT_NAME, ': ')
            for j = i, msgs.n do
                local msg = msgs[j]
                if type(msg) == 'string' then
                    if not opts_get(msg) then
                        if do_vars_sub then
                            if not vars then vars = vars_get(3) end
                            msg = vars_sub(msg, vars)
                        end
                        write(msg)
                    end
                else
                    write(tostring(msg))
                end
            end
            write(EOL)
        end
    )
end

--- Raise an error.
--
-- `xerror` should be used for run-time errors that may bubble up to the user.
-- If an error should either never be triggered to begin with or be caught
-- before it bubbles up to the user, use @{error}.
--
-- `xerror(msg, vars)` is short for
-- `error(Error{template = msg}:new(vars))`.
--
-- @string msg A message template. See @{vars_sub}.
-- @tab[opt] vars Variables.
--
-- @function xerror
-- @fixme Not unit-tested.
xerror = typed_args('string', '?table')(
    function (msg, vars)
        error(Error{template = msg}:new(vars))
    end
)

--- Raise an error if an assertion fails.
--
-- `xassert` is to @{assert} what @{xerror} is to @{error}.
--
-- @param cond A condition.
-- @string msg A message template. See @{vars_sub}.
-- @tab[opt] vars Variables. Defaults to the variables of the calling function.
-- @return The given arguments.
--
-- @function xassert
-- @fixme Not unit-tested.
function xassert(...)
    if ... then return ... end
    local _, msg, vars = ...
    if not vars then vars = vars_get(3) end
    xerror(msg, vars)
end


-----------
-- File I/O
--
-- @section

--- Check whether a path is absolute.
--
-- @string path A path.
-- @treturn bool `true` if the path is absolute, `false` otherwise.
--
-- @function path_is_abs
if not pandoc.types or PANDOC_VERSION < {2, 12} then
    path_is_abs = typed_args('string')(
        function (path)
            assert(path ~= '', 'path is the empty string.')
            if PATH_SEP == '\\' and path:match '^.:\\' then return true end
            return path:match('^' .. PATH_SEP) ~= nil
        end
    )
else
    path_is_abs = pandoc.path.is_absolute
end

do
    local get_working_directory
    if pandoc.types and PANDOC_VERSION >= {2, 8} then
        get_working_directory = pandoc.system.get_working_directory
    end

    local home_dir
    do
        if OS_TYPE == 'POSIX' then
            local env_home = os.getenv('HOME')
            if env_home and path_is_abs(env_home) then
                home_dir = path_normalise(env_home)
            end
        end
    end

    --- Prettify paths.
    --
    -- Removes the working directory from the beginning of the path. On
    -- non-Windows systems, also replaces the user's home directory with '~'.
    --
    -- @string path A path.
    -- @treturn string A prettier path.
    -- @require The working directory is removed from the
    --  beginning of the path starting with Pandoc v2.12.
    --
    -- @function path_prettify
    path_prettify = typed_args('string')(
        function (path)
            assert(path ~= '', 'path is the empty string.')
            path = path_normalise(path)
            if get_working_directory then
                local wd = get_working_directory()
                local last = #wd + 1
                if path:sub(1, last) == wd .. PATH_SEP then
                    return path:sub(last + 1)
                end
            end
            if home_dir then
                local last = #home_dir + 1
                if path:sub(1, last) == home_dir .. PATH_SEP then
                    return '~' .. path:sub(last)
                end
            end
            return path
        end
    )
end

--- Get a directory to use as working directory.
--
-- @treturn string The directory of the first input file
--  or '.' if no input files were given.
function wd ()
    local fname = PANDOC_STATE.input_files[1]
    if not fname then return '.' end
    local wd = path_split(fname)
    return wd
end

--- Check whether a file exists.
--
-- @caveats
--
-- Another process may create a file of the given name between the time
-- `file_exists` tries to access that file and the time it returns.
--
-- @string fname A filename.
-- @treturn[1] boolean `true` if the file exists.
-- @treturn[2] nil `nil` if the file does not exist.
-- @treturn[2] string An error message.
-- @treturn[2] int The error number 2.
-- @raise An error if the file cannot be closed again.
--
-- @function file_exists
file_exists = typed_args('string')(
    function (fname)
        assert(fname ~= '', 'filename is the empty string.')
        local file, err, errno = io.open(fname, 'r')
        if not file then return nil, err, errno end
        assert(file:close())
        return true
    end
)

do
    local resource_path = PANDOC_STATE.resource_path

    --- Locate a file in Pandoc's resource path.
    --
    -- @caveats Absolute filenames are returned as they are.
    --
    -- @string fname A filename.
    -- @treturn[1] string A filename in Pandoc's resource path.
    -- @treturn[2] nil `nil` if the file could not be found.
    -- @treturn[2] string An error message.
    --
    -- @function file_locate
    file_locate = typed_args('string')(
        function (fname)
            assert(fname ~= '', 'filename is the empty string.')
            if not resource_path or file_exists(fname) then return fname end
            for i = 1, #resource_path do
                local f = path_join(resource_path[i], fname)
                if file_exists(f) then return f end
            end
            return nil, fname .. ': not found in resource path.'
        end
    )
end

--- Read a file.
--
-- @string fname A filename.
-- @treturn[1] string The contents of the file.
-- @treturn[2] nil `nil` if an error occurred.
-- @treturn[2] string An error message.
-- @treturn[2] int An error number.
--
-- @function file_read
file_read = typed_args('string')(
    function (fname)
        assert(fname ~= '', 'filename is the empty string.')
        local str, err, errno, file, ok
        file, err, errno = io.open(fname, 'r')
        if not file then return nil, err, errno end
        str, err, errno = file:read('a')
        if not str then return nil, err, errno end
        ok, err, errno = file:close()
        if not ok then return nil, err, errno end
        return str
    end
)

do
    -- Write data to a file (worker).
    --
    -- @param file The name or handle of a file to write data to.
    -- @string ... The data.
    -- @treturn[1] bool `true` if the data was written out sucessfully.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    -- @treturn[2] int An error number.
    local function write (fname, ...)
        local file, ok, err, errno
        file, err, errno = io.open(fname, 'w')
        if not file then return nil, err, errno end
        ok, err, errno = file:write(...)
        if not ok then return nil, err, errno end
        ok, err, errno = file:flush()
        if not ok then return nil, err, errno end
        return file:close()
    end

    --- Write data to a file.
    --
    -- If a file of that name already exists, it is overwritten.
    --
    -- @caveats
    --
    -- Data is first written to a temporary file, that file is then renamed
    -- to the given filename. This is safe and secure starting with Pandoc
    -- v2.8. If you are using an older version of Pandoc, the caveats of
    -- @{with_tmp_file} apply.
    --
    -- @side Typically creates and deletes a temporary file.
    --
    -- @string fname A filename.
    -- @string ... The data.
    -- @treturn[1] bool `true` if the data was written to the given file.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    -- @treturn[2] int An error number.
    --
    -- @function file_write
    -- @fixme Legacy version is not unit-tested.
    file_write_legacy = typed_args('string')(
        function (fname, ...)
            assert(fname ~= '', 'filename is the empty string.')
            local dir = path_split(fname)
            local data = {...}
            return with_tmp_file(function(tf)
                local ok, err, errno
                xwarn 'writing to temporary file ${tf|path_prettify}.'
                ok, err, errno = write(tf, unpack(data))
                if not ok then return nil, err, errno end
                ok, err, errno = os.rename(tf, fname)
                if not ok then return nil, err, errno end
                xwarn 'renamed ${tf|path_prettify} to ${fname|path_prettify}.'
                return true
            end, dir)
        end
    )

    do
        local with_temporary_directory = pandoc.system.with_temporary_directory
        local get_working_directory = pandoc.system.get_working_directory

        -- Turn a relative path into an absolute one.
        --
        -- Absolute paths are returned as they are.
        --
        -- @string path The path.
        -- @treturn string An absolute path.
        local function path_make_abs (path)
            if path_is_abs(path) then return path end
            return path_join(get_working_directory(), path)
        end

        file_write_modern = typed_args('string')(
            function (fname, ...)
                assert(fname ~= '', 'filename is the empty string.')
                local dir, base = path_split(path_make_abs(fname))
                local data = {...}
                local tmp_dir
                local vs = {with_temporary_directory(dir, 'pdz', function (td)
                    tmp_dir = td
                    xwarn 'created temporary directory ${td|path_prettify}.'
                    local tmp_file = path_join(td, base)
                    local ok, err, errno = write(tmp_file, unpack(data))
                    if not ok then return nil, err, errno end
                    return os.rename(tmp_file, fname)
                end)}
                if tmp_dir and not file_exists(tmp_dir) then
                    xwarn 'removed ${tmp_dir|path_prettify}.'
                end
                return unpack(vs)
            end
        )
    end

    if not pandoc.types or PANDOC_VERSION < {2, 8}
        then file_write = file_write_legacy
        else file_write = file_write_modern
    end
end

do
    local alnum = Values()

    do
        -- These are the ASCII/UTF-8 ranges for alphanumeric characters.
        local ranges = {
            {48,  57},  -- 0-9.
            {65,  90},  -- A-Z.
            {97, 122}   -- a-z.
        }

        -- Populate alnum.
        for i = 1, #ranges do
            local first, last = unpack(ranges[i])
            for j = first, last do alnum:add(string.char(j)) end
        end
    end

    math.randomseed(os.time())

    --- Generate a name for a temporary file.
    --
    -- @caveats
    --
    -- The filename generated is only *likely* not to be in use. Another
    -- process may create a file of the same name between the time `tmp_fname`
    -- checks whether that name is in use and the time it returns.
    --
    -- @string[opt] dir A directory to prefix the filename with.
    --  Must *not* be the empty string.
    -- @string[opt='pdz-XXXXXX'] templ A template for the filename.
    --  'X's are replaced with random alphanumeric characters.
    --  Must contain at least six 'X's.
    -- @treturn[1] string A filename.
    -- @treturn[2] nil `nil` if the generated filename is in use.
    -- @treturn[2] string An error message.
    --
    -- @function tmp_fname
    tmp_fname = typed_args('?string', '?string')(
        function (dir, templ)
            if templ == nil then
                templ = 'pdz-XXXXXX'
            else
                assert(templ ~= '', 'template is the empty string.')
                local nxs = 0
                for _ in templ:gmatch 'X' do nxs = nxs + 1 end
                assert(nxs >= 6, 'template must contain at least six "X"s.')
            end
            if dir ~= nil then
                assert(dir ~= '', 'directory is the empty string.')
                templ = path_join(dir, templ)
            end
            for _ = 1, 1024 do
                local fname = ''
                for c in templ:gmatch '.' do
                    if c == 'X' then c = alnum[math.random(1, alnum.n)] end
                    fname = fname .. c
                end
                if not file_exists(fname) then return fname end
            end
            return nil, 'failed to generate an unused filename.'
        end
    )
end

--- Run a function with a temporary file.
--
-- Generates a temporary filename. Does *not* create that file.
-- If the function raises an error or returns `nil` or `false`,
-- the temporary file is deleted.
--
-- @caveats
--
-- The temporary file may have been created by *another* process. If that
-- file is located within a directory that other users have write access
-- to (e.g., `/tmp`), then this is a security issue.
--
-- @side May print error messages to STDERR.
--
-- @func func Given the name of the temporary file.
--  Must *not* change the working directory.
-- @string[opt] dir A directory to prefix the name
--  of the temporary file with. See @{tmp_fname}.
-- @string[opt] templ A template for the name
--  of the temporary file. See @{tmp_fname}.
-- @return The values returned by the function.
--
-- @function with_tmp_file
with_tmp_file = typed_args('function', '?string', '?string')(
    function (func, dir, templ)
        local tmp_file, err = tmp_fname(dir, templ)
        if not tmp_file then return nil, err end
        local vs = pack(pcall(func, tmp_file))
        local ok, val = unpack(vs)
        if not ok or not val then
            -- luacheck: ignore ok err
            xwarn 'removing ${fname|path_prettify}.'
            local ok, err, errno = os.remove(tmp_file)
            if not ok and errno ~= 2 then xwarn('@error', '@plain', err) end
        end
        return unpack(vs, 2)
    end
)


-------------
-- Networking
--
-- @section

--- Retrieve data from a URL via an HTTP GET request.
--
-- @string url The URL.
-- @treturn string The MIME type of the HTTP content.
-- @treturn string The HTTP content itself.
-- @raise An error if the host cannot be reached.
--  This error can be caught starting with Pandoc v2.11.
--
-- @function http_get
http_get = typed_args('string')(
    function (url)
        assert(url ~= '', 'URL is the empty string.')
        return pandoc.mediabag.fetch(url, '.')
    end
)

do
    -- Percent-encode a character for use in an URI.
    --
    -- @string char A character.
    -- @treturn string A percent-encoding.
    --
    -- @see uri_escape
    local function escape (char)
        return format('%%%02x', string.byte(char))
    end

    --- Percent-encode a string for use in an URI.
    --
    -- @string str A string.
    -- @treturn string A percent-encoded string.
    --
    -- See [RFC 3987](https://datatracker.ietf.org/doc/html/rfc3987).
    --
    -- @function uri_escape
    -- @fixme Not unit-tested.
    uri_escape = typed_args('string')(
        function (str)
            return str:gsub('[^%w%-_%.~]', escape), nil
        end
    )
end

--- Query a URL via an HTTP GET request.
--
-- @string url The URL.
-- @tparam[opt] {string=string,...} params Request parameters.
-- @treturn string The MIME type of the HTTP content.
-- @treturn string The HTTP content itself.
-- @raise See @{http_get}.
--
-- @usage
-- -- Query <https://site.example?foo=1&bar=2>.
-- mt, con = url_query('https://site.example', {foo = 1, bar = 2})
--
-- @function url_query
url_query = typed_args('string', '?table')(
    function (url, params)
        assert(url ~= '', 'URL is the empty string.')
        if params then
            local query = Values()
            for k, v in sorted(params) do query:add(k .. '=' ..v) end
            url = url .. '?' .. concat(query, '&')
        end
        return http_get(url)
    end
)


--------------------
-- Markup converters
--
-- @section

do
    -- Escape bold and italics meta characters.
    local function escape_bold_italics (char, tail)
        return char:gsub('(.)', '\\%1') .. tail
    end

    -- Escape superscript and subscript meta characters.
    local function escape_sup_sub (head, body, tail)
        return head:gsub('(.)', '\\%1') .. body .. tail:gsub('(.)', '\\%1')
    end

    -- Escape brackets.
    local function escape_brackets (char, tail)
        return '\\[' .. char:sub(2, -2) .. '\\]' .. tail
    end

    -- Pairs of expressions and replacement functions.
    local patterns = {
        -- Backslashes.
        {'(\\+)', '\\%1'},
        -- Bold and italics.
        -- This escapes liberally, but it is the only way to cover edge cases.
        {'(%*+)([^%s%*])', escape_bold_italics},
        {'(_+)([^%s_])', escape_bold_italics},
        -- Superscript and subscript.
        {'(%^+)([^%^%s]*)(%^+)', escape_sup_sub},
        {'(~+)([^~%s]+)(~+)', escape_sup_sub},
        -- Brackets (spans and links).
        {'(%b[])([%({])', escape_brackets}
    }

    local npatterns = #patterns

    --- Escape Markdown syntax.
    --
    -- @caveats
    --
    -- Only escapes [Markdown that Pandoc recognises in bibliographic
    -- data](https://pandoc.org/MANUAL.html#specifying-bibliographic-data).
    --
    -- @string str Non-markdown text.
    -- @treturn string Text with markdown syntax escaped.
    --
    -- @usage
    -- > escape_markdown '*text*'
    -- \*text*
    --
    -- @function escape_markdown
    escape_markdown = typed_args('string')(
        function (str)
            for i = 1, npatterns do
                local pattern, repl = unpack(patterns[i])
                str = str:gsub(pattern, repl)
            end
            return str
        end
    )
end

do
    -- Filter to escape Markdown in Pandoc string elements.
    local escape_str = {}

    -- Escape Markdown in a string element.
    --
    -- Works like @{escape_markdown} but for Pandoc string elements.
    --
    -- @tparam pandoc.Str str A Pandoc string element.
    -- @treturn pandoc.Str A string with all Markdown syntax escaped.
    function escape_str.Str (str)
        str.text = escape_markdown(str.text)
        return str
    end

    -- Filter to convert to Markdown.
    local to_markdown = {}

    -- Make a function that converts an element to Markdown.
    --
    -- @string char A Markdown markup character.
    -- @treturn func A conversion function.
    local function make_converter (char)
        return function (elem)
            local str = stringify(pandoc.walk_inline(elem, to_markdown))
            return Str(char .. str .. char)
        end
    end

    -- Convert AST elements into Markdown text.
    to_markdown.Emph = make_converter '*'
    to_markdown.Strong = make_converter '**'
    to_markdown.Subscript = make_converter '~'
    to_markdown.Superscript = make_converter '^'

    -- Convert HTML span elements to Markdown text.
    --
    -- @tparam pandoc.Span An HTML span element.
    -- @treturn pandoc.Str A Markdown representation.
    function to_markdown.Span (span)
        local str = stringify(pandoc.walk_inline(span, to_markdown))
        local attrs = Values()

        local identifier = span.identifier
        if identifier and identifier ~= '' then
            attrs:add('#' .. identifier)
        end

        local classes = span.classes
        if classes then
            for i = 1, #classes do
                attrs:add('.' .. classes[i])
            end
        end

        local attributes = span.attributes
        if attributes then
            for k, v in pairs(attributes) do
                attrs:add(format('%s="%s"', k, v))
            end
        end

        if attrs.n > 0 then
            str = '[' .. str ..                ']' ..
                  '{' .. concat(attrs, ' ') .. '}'
        end
        return Str(str)
    end

    -- Convert a Pandoc small capitals elements to Markdown text.
    --
    -- @tparam pandoc.SmallCaps A SmallCaps element.
    -- @treturn pandoc.Str A Markdown representation.
    function to_markdown.SmallCaps (sc)
        local span = Span(sc.content)
        span.attributes.style = 'font-variant: small-caps'
        return to_markdown.Span(span)
    end

    --- Convert a Pandoc element to Markdown text.
    --
    -- @caveats
    --
    -- Only recognises [elements Pandoc permits in bibliographic
    -- data](https://pandoc.org/MANUAL.html#specifying-bibliographic-data).
    --
    -- @tparam pandoc.AstElement elem A Pandoc AST element.
    -- @treturn string Markdown text.
    --
    -- @function markdownify
    markdownify = typed_args('table|userdata')(
        function (elem)
            local escaped = elem_walk(elem, escape_str)
            return stringify(elem_walk(escaped, to_markdown))
        end
    )
end

do
    local rep = string.rep
    local char = utf8.char
    local codes = utf8.codes

    --- Create a number of spaces.
    --
    -- @int n The number of spaces.
    -- @treturn string `n` spaces.
    local function spaces (n)
        return rep(' ', n)
    end

    --- Convert a string to a YAML scalar.
    --
    -- @caveats
    --
    -- * Strings *must* be encoded in UTF-8.
    -- * Does *not* escape *all* non-printable characters.
    --
    -- @string str A string.
    -- @bool[opt] unquoted Quote strings only when needed?
    -- @treturn string A YAML scalar.
    local function scalarify (str, unquoted)
        -- Simple strings may need no special treatment.
        if
            unquoted                and
            not str:match '^%d+$'   and
            str:match '^[%w%s%-]+$'
        then return str end

        -- Replace line breaks with the OS' EOL sequence.
        str = str:gsub('\r?\n', EOL)

        -- Escape special and forbidden characters.
        local chars = Values()
        for _, c in codes(str, true) do
            if
                c == 0x22 or -- '"'
                c == 0x5c    -- '\'
            then
                chars:add('\\' .. char(c))
            elseif
                c == 0x09 or -- TAB
                c == 0x0a or -- LF
                c == 0x0d or -- CR
                c == 0x85    -- NEL
            then
                chars:add(char(c))
            elseif
                c <= 0x001f or -- C0 control block
                c == 0x007f    -- DEL
            then
                chars:add(format('\\x%02x', c))
            elseif
                (0x0080 <= c and c <= 0x009f) or -- C1 control block
                (0xd800 <= c and c <= 0xdfff) or -- Surrogate block
                c == 0xfffe or
                c == 0xffff
            then
                chars:add(format('\\u%04x', c))
            else
                chars:add(char(c))
            end
        end
        str = concat(chars)

        -- Quote.
        return '"' .. str .. '"'
    end

    -- Convert Lua to YAML types.
    local converters = {}
    converters.boolean = tostring
    converters.number = tostring
    converters.string = scalarify

    --- Generate a YAML representation of a value.
    --
    -- Terminates lines with @{EOL}.
    --
    -- @caveats
    --
    -- * Mangles strings in encodings other than UTF-8.
    -- * Does *not* escape *all* non-printable characters (because Unicode).
    --
    -- @param val A value.
    -- @int[opt=4] ind How many spaces to indent blocks.
    -- @func[opt] sort A function to sort keys of mappings.
    --  Defaults to lexical sorting.
    -- @treturn[1] string A YAML string.
    -- @treturn[2] nil `nil` if the data cannot be represented in YAML.
    -- @treturn[2] string An error message.
    --
    -- @function yamlify
    -- @fixme Indentation and sorting are not unit-tested.
    yamlify = typed_args('*', '?number', '?function', '?number', '?table')(
        -- luacheck: ignore sort
        function (val, ind, sort, _col, _seen)
            if not _seen then _seen = {} end
            assert(not _seen[val], 'cycle in data tree.')
            if not ind then ind = 4 end
            local t = type(val)
            local conv = converters[t]
            if conv then return conv(val) end
            assert(t == 'table', t .. ': cannot be expressed in YAML.')
            _seen[val] = true
            if not _col then _col = 0 end
            local strs = Values()
            local n = #val
            local nkeys = select(2, keys(val))
            local sp = spaces(_col)
            if n == nkeys then
                local col = _col + 2
                for i = 1, n do
                    local v = val[i]
                    if i > 1 then strs:add(sp) end
                    strs:add('- ', yamlify(v, ind, sort, col, _seen))
                    if i ~= n then strs:add(EOL) end
                end
            else
                local i = 0
                for k, v in sorted(val, sort) do
                    i = i + 1
                    if type(k) == 'number' then k = tostring(k)
                                           else k = scalarify(k, true)
                    end
                    if i > 1 then strs:add(sp) end
                    strs:add(k, ':')
                    local col = _col + ind
                    if type(v) == 'table' then strs:add(EOL, spaces(col))
                                          else strs:add ' '
                    end
                    strs:add(yamlify(v, ind, sort, col, _seen))
                    if i ~= nkeys then strs:add(EOL) end
                end
            end
            return concat(strs)
        end
    )
end

--- Convert Zotero pseudo-HTML to proper HTML.
--
-- @string pseudo Zotero pseudo-HTML code.
-- @treturn string HTML code.
--
-- @function zotero_to_html
-- @raise An @{Error} if the opening `<sc>` and the closing `</sc>`
--  tags are unbalanced.
zotero_to_html = typed_args('string')(
    function (pseudo)
        local opened, closed, n, m
        opened, n = pseudo:gsub('<sc>',
                                '<span style="font-variant: small-caps">')
        if n == 0 then return pseudo end
        closed, m = opened:gsub('</sc>',
                                '</span>')
        xassert(m == n, '"${pseudo}": contains ${n} <sc> but ${m} </sc> tags.')
        return closed
    end
)

--- Convert Zotero pseudo-HTML to Markdown.
--
-- @caveats
--
-- Only supports [pseudo-HTML that Pandoc recognises in bibliographic
-- data](https://pandoc.org/MANUAL.html#specifying-bibliographic-data).
--
-- @string pseudo Zotero pseudo-HTML code.
-- @treturn string Markdown text.
-- @raise See @{zotero_to_html}.
--
-- @function zotero_to_markdown
zotero_to_markdown = typed_args('string')(
    function (pseudo)
        local html = zotero_to_html(pseudo)
        local ok, doc = pcall(read, html, 'html')
        xassert(ok, '"${pseudo}": cannot parse Zotero pseudo-HTML.')
        return markdownify(doc)
    end
)


------------
-- CSL items
--
-- @section

--- Preferred order of CSL variables.
--
-- @see csl_vars_sort
CSL_VARS_ORDER = {
    'id',                       -- Item ID.
    'type',                     -- For example, 'paper', 'book'.
    'author',                   -- Author(s).
    'original-author',          -- Original author(s).
    'recipient',                -- Recipient of the document.
    'status',                   -- Publication status (e.g., 'forthcoming').
    'issued',                   -- When the item was published.
    'original-date',            -- Original date.
    'title',                    -- The title.
    'title-short',              -- A short version of the title.
    'short-title',              -- Ditto.
    'translator',               -- Translator(s).
    'editor',                   -- The editor(s).
    'container-title',          -- Publication the item was published in.
    'container-title-short',    -- A short version of that title.
    'collection-title',         -- E.g., a series.
    'collection-title-short',   -- A short version of the title.
    'edition',                  -- Container's edition.
    'volume',                   -- Volume no.
    'issue',                    -- Issue no.
    'page-first',               -- First page.
    'page',                     -- Pages or page range *or* number of pages.
    'publisher',                -- Publisher.
    'publisher-place',          -- City/cities the item was published in.
    'original-title',           -- Original title.
    'original-publisher',       -- Original publisher.
    'original-publisher-place', -- Place the item was originally published in.
    'doi',                      -- The DOI.
    'pmcid',                    -- PubMed Central reference number.
    'pmid',                     -- PubMed reference number.
    'url',                      -- The URL.
    'accessed',                 -- When the URL was last accessed.
    'isbn',                     -- The ISBN of the item.
    'issn',                     -- The ISSN of the container.
    'call-number',              -- Call number (of a library).
    'language',                 -- Language the item is in.
    'abstract',                 -- The abstract.
}

do
    --- Normalise a CSL key-value pair.
    --
    -- @string key A CSL key.
    -- @string val A value.
    -- @treturn[1] string A normalised CSL key.
    -- @treturn[1] string A trimmed value
    -- @see csl_varname_normalise
    local function normalise (key, val)
        if not key or not val then return end
        key = csl_varname_normalise(key)
        if not key then return end
        val = trim(val)
        if val == '' then return end
        return key, val
    end

    -- Create a function that iterates over "extra" field entries.
    --
    -- Uses the newer `<variable name>: <value><linefeed>` syntax.
    --
    -- @string extra Contents of a Zotero "extra" field.
    -- @treturn func A *stateful* iterator.
    local function make_iter (extra)
        local next_line = split(extra, '\r?\n')
        return function ()
            while true do
                local ln = next_line()
                while ln and ln:match '^%s*$' do ln = next_line() end
                if not ln then return end
                local k, v = normalise(tabulate(split(ln, '%s*:%s*'), 2))
                if k then return k, v end
            end
        end
    end

    -- Create a function that iterates over legacy "extra" field entries.
    --
    -- Uses the older `{:<variable name>: <value>}` syntax.
    --
    -- @string note The contents of a Zotero "extra" field.
    -- @treturn func A *stateful* iterator.
    local function make_legacy_iter (note)
        local next_pair = note:gmatch '{:([%a-]+):%s*([^}]+)}'
        return function ()
            while true do
                local k, v = next_pair()
                if not k then return end
                k, v = normalise(k, v)
                if k then return k, v end
            end
        end
    end

    --- Iterate over every key-value pair in the "note" field of a CSL item.
    --
    -- @caveats
    --
    -- Assumes that the "note" field is used to store entries that
    -- were added to Zotero's ["extra" field](https://perma.cc/EGN3-78CH).
    --
    -- @tab item A CSL item.
    -- @treturn func A *stateful* iterator.
    --
    -- @see csl_item_add_extras
    -- @function csl_item_extras
    csl_item_extras = typed_args('table')(
        function (item)
            local note = item.note
            if not note then return function () return end end
            local i = 1
            local next_pair = make_iter(note)
            return function ()
                while true do
                    local k, v = next_pair()
                    if k then return k, v end
                    i = i + 1
                    if i > 2 then break end
                    next_pair = make_legacy_iter(note)
                end
            end
        end
    )
end

do
    local insert = table.insert

    -- Parse a date in Zotero's extra field.
    --
    -- @caveats The item is modified in-place.
    --
    -- @tab item A CSL item.
    -- @string key A field name.
    -- @string val A value.
    local function parse_date (item, key, val)
        local parts = {}
        local i = 0
        for iso in split(val, '/', 2) do
            i = i + 1
            local year, month, day = iso:match '^(%d%d%d%d)%-?(%d*)%-?(%d*)$'
            if year then
                local date = {year}
                if month and month ~= '' then
                    date[2] = month
                    if day and day ~= '' then
                        date[3] = day
                    end
                end
                parts[i] = date
            elseif i == 1 then
                xwarn('@error', '${item.id}: cannot parse extra field ${key}.')
                return
            end
        end
        item[key] = {['date-parts'] = parts}
    end

    -- Parse a name in Zotero's extra field.
    --
    -- @caveats The item is modified in-place.
    --
    -- @tab item A CSL item.
    -- @string key A field name.
    -- @string val A value.
    local function parse_name (item, key, val)
        local family, given = tabulate(split(val, '%s*%|%|%s*', 2))
        if not item[key] then item[key] = {} end
        if family and family ~= '' and given and given ~= '' then
            insert(item[key], {family = family, given = given})
        else
            insert(item[key], val)
        end
    end

    -- Mapping of CSL field names to functions that take an item and a field
    -- name-value pair and *add* that field to the CSL item *in-place*.
    local parsers = {
        ['accessed'] = parse_date,
        ['container'] = parse_date,
        ['event-date'] = parse_date,
        ['issued'] = parse_date,
        ['original-date'] = parse_date,
        ['submitted'] = parse_date,
        ['author'] = parse_name,
        ['collection-editor'] = parse_name,
        ['composer'] = parse_name,
        ['container-author'] = parse_name,
        ['director'] = parse_name,
        ['editor'] = parse_name,
        ['editorial-director'] = parse_name,
        ['managing-editor'] = parse_name,
        ['illustrator'] = parse_name,
        ['interviewer'] = parse_name,
        ['original-author'] = parse_name,
        ['recipient'] = parse_name,
        ['reviewed-author'] = parse_name,
        ['translator'] = parse_name
    }

    --- Add CSL variables from the "note" field to the item proper.
    --
    -- @tab item A CSL item.
    -- @treturn table The item with variables from "extra" copied.
    --
    -- @function csl_item_add_extras
    csl_item_add_extras = typed_args('table')(
        function (item)
            local ret = copy(item)
            for k, v in csl_item_extras(item) do
                local f = parsers[k]
                if not ret[k] or f == parse_date or k == 'type' then
                    if f then
                        f(ret, k, v)
                    -- At least until CSL v1.2 is out and
                    -- 'citekey' becomes official.
                    elseif k ~= 'citation-key' and k ~= 'citekey' then
                        ret[k] = v
                    end
                end
            end
            return ret
        end
    )
end

--- Normalise variable names of a CSL item.
--
-- @tab item A CSL item.
-- @treturn tab A normalised item.
-- @see csl_varname_normalise
--
-- @function csl_item_normalise_vars
csl_item_normalise_vars = typed_args('table', '?table')(
    function (item, _seen)
        if     not _seen   then _seen = {}
        elseif _seen[item] then return _seen[item]
        end
        local ret = {}
        _seen[item] = ret
        for k, v in pairs(item) do
            if type(k) == 'string' then
                k = csl_varname_normalise(k)
            end
            if k then
                if type(v) == 'table' then
                    v = csl_item_normalise_vars(v, _seen)
                end
                ret[k] = v
            end
        end
        return ret
    end
)

do
    -- A mapping of Lua type names to functions that construct Pandoc types.
    local converters = {}

    --- Convert a CSL Item to a Pandoc metadata type (worker).
    --
    -- @tab item CSL item.
    -- @param ... Passed on to per-type conversion function.
    -- @treturn pandoc.MetaValue A Pandoc metadata value.
    -- @raise An error if a type cannot be converted to a Pandoc metadata type.
    local function convert (item, ...)
        local t = type(item)
        local f = converters[t]
        assert(f, t .. ': cannot be converted to a Pandoc metadata type.')
        return f(item, ...)
    end

    -- Convert a Lua boolean to a pandoc.MetaBool
    --
    -- @bool bool A boolean value.
    -- @treturn pandoc.MetaBool The value.
    function converters.boolean (bool)
        return pandoc.MetaBool(bool)
    end

    -- Convert a Lua number to a pandoc.MetaInlines string.
    --
    -- @bool num A number.
    -- @treturn pandoc.MetaInlines The number.
    function converters.number (num)
        return MetaInlines(List{Str(tostring(num))})
    end

    -- Convert Zotero pseudo-HTML to a pandoc.MetaInlines string.
    --
    -- @string str A string.
    -- @treturn pandoc.MetaInlines A string.
    function converters.string (str)
        local html = zotero_to_html(str)
        local inlines = read(html, 'html').blocks[1].content
        return MetaInlines(inlines)
    end

    -- Convert a Lua table to a pandoc.MetaMapping.
    --
    -- @tab tab A table.
    -- @treturn pandoc.MetaMapping The table.
    -- @fixme Recursion protection is not unit-tested.
    function converters.table (tab, _seen)
        if     not _seen  then _seen = {}
        elseif _seen[tab] then error 'cycle in data tree.'
        end
        _seen[tab] = true
        local nkeys = select(2, keys(tab))
        local n = #tab
        if n == nkeys then
            local list = MetaList{}
            for i = 1, n do
                list[i] = convert(tab[i], _seen)
            end
            return list
        end
        local map = MetaMap{}
        for k, v in pairs(tab) do map[k] = convert(v, _seen) end
        return map
    end

    --- Convert a CSL item to a Pandoc metadata value.
    --
    -- @tab item A CSL item.
    -- @treturn pandoc.MetaMap A Pandoc metadata value.
    -- @raise An error if an item cannot be converted to
    --  a Pandoc metadata value.
    --
    -- @function csl_item_to_meta
    -- @fixme Not unit-tested.
    csl_item_to_meta = typed_args('table')(convert)
end

--- Filter CSL items by their citation key.
--
-- @tparam {tab,...} items CSL items.
-- @string ckey A citation key (e.g., `'doe:2020word'`, `'DoeWord2020'`).
-- @treturn {tab,...} Items with that citation key.
--
-- @function csl_items_filter_by_ckey
-- @fixme Not unit-tested.
csl_items_filter_by_ckey = typed_args('table', 'string')(
    function (items, ckey)
        local filtered = Values()
        for i = 1, #items do
            local item = items[i]
            for k, v in csl_item_extras(item) do
                if (k == 'citation-key' or k == 'citekey') and v == ckey then
                    filtered:add(item)
                    break
                end
            end
        end
        return filtered
    end
)

--- Pick the IDs of CSL items out of a list of CSL items.
--
-- @side May print error messages to STDERR.
--
-- @tparam {tab,...} items CSL items.
-- @treturn Set Item IDs.
--
-- @function csl_items_ids
csl_items_ids = typed_args('table')(
    function (items)
        local ids = {}
        for i = 1, #items do
            local id = items[i].id
            local t = type(id)
            if     t == 'number'   then id = tostring(id)
            elseif t == 'userdata' then id = stringify(id)
            elseif t == 'table'    then id = stringify(id)
            end
            if type(id) == 'string' and id ~= ''
                then ids[id] = true
                else xwarn('@error', 'ignoring CSL item witout parsable ID.')
            end
        end
        return ids
    end
)

--- Sort CSL items by their ID.
--
-- @caveats Assumes that CSL item IDs are of the same type.
--
-- @tab a A CSL item.
-- @tab b Another CSL item.
-- @treturn bool Whether item A comes before item B.
--
-- @function csl_items_sort
csl_items_sort = typed_args('table', 'table')(
    function (a, b)
        return a.id < b.id
    end
)

--- Normalise a CSL variable name.
--
-- Trim the variable name, lowercase it, and replace spaces with dashes.
--
-- @string var A CSL variable name.
-- @treturn[1] string A normalised variable name.
-- @treturn[2] nil `nil` if the string is not a CSL variable name.
-- @treturn[2] string An error message.
--
-- @usage
-- > csl_varname_normalise 'Original date'
-- original-date
--
-- @function csl_varname_normalise
csl_varname_normalise = typed_args('string')(
    function (var)
        var = trim(var):gsub(' ', '-'):lower()
        if var:match '^[%a%-]+$' then return var end
        if var == '' then return nil, 'variable name is the empty string.' end
        return nil, var .. ': not a variable name.'
    end
)

--- Sort CSL variables.
--
-- Sorts variables in the order in which they are listed in @{CSL_VARS_ORDER}.
-- Unlisted variables are placed after listed ones in lexical order.
--
-- @string a A CSL variable name.
-- @string b Another CSL variable name.
-- @treturn bool Whether variable A should come before variable B.
--
-- @function csl_vars_sort
csl_vars_sort = typed_args('string', 'string')(order(CSL_VARS_ORDER))

do
    local decode = json.decode
    local floor = math.floor

    -- Convert numbers to strings.
    --
    -- Floating point numbers are converted to integers.
    -- Data of other types is returned as is.
    --
    -- @tab data The data.
    -- @return The converted data.
    local function num_to_str (data)
        if type(data) ~= 'number' then return data end
        return tostring(floor(data))
    end

    --- Parse a CSL JSON string.
    --
    -- @string str A CSL JSON string.
    -- @treturn[1] tab A single CSL item or a list of CSL items.
    -- @treturn[2] nil `nil` if the string cannot be parsed.
    -- @treturn[2] string An error message.
    --
    -- @function csl_json_parse
    csl_json_parse = typed_args('string')(
        function (str)
            if str == '' then return nil, 'got the empty string.' end
            local ok, data = pcall(decode, str)
            if not ok then return nil, 'cannot parse: ' .. str end
            return csl_item_normalise_vars(walk(data, num_to_str))
        end
    )
end


----------------
-- Citation keys
-- @section

--- An interface for parsing citation keys.
--
-- @object citekey
-- @proto @{Object}
citekey = Object()

--- A mapping of citation key types to parsers.
--
-- A parser must take a citation key and return search terms or `nil` and
-- an error message if no search terms can be derived from the citation key.
citekey.parsers = {}

do
    local len = utf8.len

    --- Guess search terms from a BetterBibTeX citation key.
    --
    -- Splits up a BetterBibTeX citation key at each uppercase letter
    -- and at each start of a string of digits.
    --
    -- @caveats BetterBibTeX citation keys must be encoded in ASCII.
    --
    -- @string ckey A BetterBibTeX citation key (e.g., `'DoeWord2020'`).
    -- @treturn[1] {string,...} Search terms.
    -- @treturn[2] nil `nil` if no search terms could be derived.
    -- @treturn[2] string An error message.
    --
    -- @function citekey.parsers.betterbibtexkey
    -- @fixme Not unit-tested.
    citekey.parsers.betterbibtexkey = typed_args('string')(
        function (ckey)
            assert(ckey ~= '', 'citation key is the empty string.')
            local terms = Values()
            for str, num in ckey:gmatch '([%a%p]*)(%d*)' do
                if str and str ~= '' then
                    for term in split(str, '%u', nil, 'l') do
                        local l = len(term)
                        if l and l >= 3 then terms:add(term) end
                    end
                end
                if num and num ~= '' then
                    local l = len(num)
                    if l and l > 1 then terms:add(num) end
                end
            end
            if terms.n < 1 then
                return nil, 'not a BetterBibTex citation key.' end
            return terms
        end
    )
end

do
    local codes = utf8.codes

    --- Guess search terms from an Easy Citekey.
    --
    -- Splits up an Easy Citekey into an author, a year, and a word.
    --
    -- @caveats Easy Citekeys must be encoded in UTF-8.
    --
    -- @string ckey A zotxt Easy Citekey (e.g., `'doe:2020word'`).
    -- @treturn[1] {string,...} Search terms.
    -- @treturn[2] nil `nil` if no search terms could be derived.
    -- @treturn[2] string An error message.
    --
    -- @function citekey.parsers.easykey
    -- @fixme Not unit-tested.
    citekey.parsers.easykey = typed_args('string')(
        function (ckey)
            assert(ckey ~= '', 'citation key is the empty string.')
            local terms = Values()
            local colon = false
            for p, c in codes(ckey) do
                if not colon then
                    -- 58 is the colon (:).
                    if c == 58 then
                        local s = ckey:sub(1, p - 1)
                        if s and s ~= '' then terms:add(s) end
                        colon = true
                    end
                else
                    -- Digits start at 48 and end at 57.
                    if c >= 48 and c <= 57 then
                        if terms.n < 2 then terms:add '' end
                        terms[2] = terms[2] .. tostring(c - 48)
                    else
                        local s = ckey:sub(p)
                        if s and s ~= '' then terms:add(s) end
                        break
                    end
                end
            end
            if terms.n < 2 then
                return nil, 'not an Easy Citekey.'
            end
            return terms
        end
    )
end

--- Guess search terms from a citation key.
--
-- @caveats
--
-- The citation key types 'key' and 'easykey' go before 'betterbibtexkey'.
-- It is unlikely that the Zotero item ID parser or the Easy Citekey would
-- parse a Better BibTeX citation key. But the BetterBibTeX citation parser
-- does 'parse' Zotero item IDs as well as Easy Citekey, wrongly.
--
-- @string ckey A citation key (e.g., `'doe:2020word'`, `'DoeWord2020'`).
-- @tparam {string,...} types Types to try to parse the citation key as.
--  If @{citekey.parsers} contains no parser for a type, it is ignored.
--  Order is significant.
-- @treturn[1] {string,...} Search terms.
-- @treturn[2] nil `nil` if no search terms could be derived.
-- @treturn[2] string An error message.
--
-- @function citekey:guess_terms
citekey.guess_terms = typed_args('table', 'string', 'table')(
    function (self, ckey, types)
        assert(ckey ~= '', 'citation key is the empty string.')
        assert(#types > 0, 'list of citation key types is empty.')
        for i = 1, #types do
            local parse = self.parsers[types[i]]
            if parse then
                local terms = parse(ckey)
                if terms then return terms end
            end
        end
        return nil, format('cannot guess search terms for %s.', ckey)
    end
)


---------------------
-- Bibliography files
-- @section

--- An interface for reading, writing, and updating bibliography files.
--
-- @object biblio
-- @proto @{Object}
biblio = Object()

--- A case-insensitive mapping of filename suffices to codecs.
biblio.types = setmetatable({}, ignore_case)

--- Decode BibLaTeX.
biblio.types.bib = {}

--- Read the IDs from the contents of a BibLaTeX file.
--
-- @string str The contents of a BibLaTeX file.
-- @treturn {{['id']=string},...} Key-value pairs.
--
-- @function biblio.types.bib.decode
biblio.types.bib.decode = typed_args('string')(
    function (str)
        local ids = Values()
        for id in str:gmatch '@%w+%s*{%s*([^%s,]+)' do ids:add{id = id} end
        return ids
    end
)

--- Decode BibTeX.
biblio.types.bibtex = {}

--- Read the IDs from the contents of a BibTeX file.
--
-- @string str The contents of a BibTeX file.
-- @treturn {{['id']=string},...} Key-value pairs.
--
-- @function biblio.types.bibtex.decode
biblio.types.bibtex.decode = biblio.types.bib.decode

--- De-/Encode CSL items in JSON.
biblio.types.json = {}

--- Parse a CSL JSON string.
--
-- @string str A CSL JSON file.
-- @treturn {tab,...} CSL items.
--
-- @function biblio.types.json.decode
biblio.types.json.decode = csl_json_parse

--- Serialise a list of CSL items to a JSON string.
--
-- @tparam {tab,...} items CSL items.
-- @treturn string A CSL YAML string.
--
-- @function biblio.types.json.encode
biblio.types.json.encode = json.encode

--- De-/Encode CSL items in YAML.
biblio.types.yaml = {}

--- Parse a CSL YAML string.
--
-- @caveats Converts formatting to Markdown, not Zotero pseudo-HTML.
--
-- @string str A CSL YAML string.
-- @treturn {tab,...} CSL items.
--
-- @function biblio.types.yaml.decode
biblio.types.yaml.decode = typed_args('string')(
    function (str)
        local next_line = str:gmatch '(.-)\r?\n'
        local ln = next_line(str, nil)
        while ln and ln ~= '---' do ln = next_line(str, ln) end
        if not ln then str = concat{'---', EOL, str, EOL, '...', EOL} end
        local doc = read(str, 'markdown')
        if not doc.meta.references then return {} end
        local refs = elem_walk(doc.meta.references, {
            Blocks = markdownify,
            Inlines = markdownify,
            MetaBlocks = markdownify,
            MetaInlines = markdownify
        })
        for i = 1, #refs do refs[i] = csl_item_normalise_vars(refs[i]) end
        return refs
    end
)

do
    -- Convert Zotero pseudo-HTML to Markdown in CSL fields.
    --
    -- @param value A field value.
    -- @treturn[1] string Markdown text if the value contained pseudo-HTML.
    -- @treturn[2] nil `nil` if the value is not a `string`.
    local function to_markdown (value)
        if type(value) ~= 'string' then return end
        return zotero_to_markdown(value)
    end

    --- Serialise a list of CSL items to a YAML string.
    --
    -- @tparam {tab,...} items CSL items.
    -- @treturn string A CSL YAML string.
    -- @raise See @{yamlify} and @{zotero_to_markdown}.
    --
    -- @function biblio.types.yaml.encode
    biblio.types.yaml.encode = typed_args('table')(
        function (items)
            sort(items, csl_items_sort)
            items = walk(items, to_markdown)
            return yamlify({references=items}, nil, csl_vars_sort)
        end
    )
end

--- Alternative suffix for YAML files.
biblio.types.yml = biblio.types.yaml

--- Read a bibliography file.
--
-- The filename suffix determines the file's format.
-- @{biblio.types} must contain a matching decoder.
--
-- @string fname A filename.
-- @treturn[1] tab CSL items.
-- @treturn[2] nil `nil` if an error occurred.
-- @treturn[2] string An error message.
-- @treturn[2] ?int An error number if the error is an I/O error.
--
-- @function biblio:read
biblio.read = typed_args('table', 'string')(
    function (self, fname)
        assert(fname ~= '', 'filename is the empty string')
        local suffix = fname:match '%.(%w+)$'
        if not suffix then return nil, fname .. ': no filename suffix.' end
        local codec = self.types[suffix]
        if not codec then return nil, fname .. ': unsupported format.' end
        local decode = codec.decode
        if not decode then return nil, fname .. ': cannot parse format.' end
        local str, err, errno = file_read(fname)
        if not str then return nil, err, errno end
        local ok, ret = pcall(decode, str)
        if not ok then return nil, fname .. ': ' .. ret end
        return ret
    end
)

--- Write bibliographic data to a bibliography file.
--
-- The filename suffix determines the file's format.
-- @{biblio.types} must contain a matching encoder.
--
-- If no CSL items are given, tests whether data can be serialised
-- in the given format *without* chaging the file.
--
-- @caveats See @{file_write}.
--
-- @string fname A filename.
-- @tab[opt] items CSL items.
-- @treturn[1] string The filename suffix.
-- @treturn[2] nil `nil` if an error occurred.
-- @treturn[2] string An error message.
-- @treturn[2] ?int An error number if the error is an I/O error.
--
-- @function biblio:write
biblio.write = typed_args('table', 'string', '?table')(
    function (self, fname, items)
        local ok, err, errno, ret, suffix, codec, encode
        assert(fname ~= '', 'filename is the empty string')
        suffix = fname:match '%.(%w+)$'
        if not suffix then return nil, fname .. ': no filename suffix.' end
        codec = self.types[suffix]
        if not codec then return nil, fname .. ': unsupported format.' end
        encode = codec.encode
        if not encode then return nil, fname .. ': cannot write format.' end
        if not items or #items == 0 then return suffix end
        ok, ret = pcall(encode, items)
        if not ok then return nil, fname .. ': ' .. ret end
        ok, err, errno = file_write(fname, ret, EOL)
        if not ok then return nil, err, errno end
        return suffix
    end
)

--- Add new items from Zotero to a bibliography file.
--
-- @caveats See @{file_write}.
-- @side May print error messages to STDERR.
--
-- @tparam connectors.Zotxt|connectors.ZoteroWeb handle A Zotero handle.
-- @string fname The name of the bibliography file.
-- @tparam {string,...} ckeys The citation keys of the items to add
--  (e.g., `{'doe:2020word'}`).
-- @treturn[1] bool `true` if the file was updated or no update was required.
-- @treturn[2] nil `nil` if an error occurrs.
-- @treturn[2] string An error message.
-- @treturn[2] ?int An error number if the error is a file I/O error.
-- @raise See @{http_get}.
--
-- @function biblio:update
-- @todo Use sets so that the loop gets simpler.
biblio.update = typed_args('table', 'table', 'string', 'table')(
    function (self, handle, fname, ckeys)
        -- luacheck: ignore fmt err errno
        assert(fname ~= '', 'filename is the empty string')
        if #ckeys == 0 then return true end
        local fmt, err = self:write(fname)
        if not fmt then return nil, err end
        local items, err, errno = biblio:read(fname)
        if not items then
            if errno ~= 2 then return nil, err, errno end
            items = {}
        end
        local ids = csl_items_ids(items)
        local nitems = #items
        local n = nitems
        for i = 1, #ckeys do
            local ckey = ckeys[i]
            if not ids[ckey] then
                local vs = pack(pcall(handle.fetch, handle, ckey))
                local ok, err = unpack(vs, 1, 2)
                if not ok then
                    if type(err) ~= 'table' then error(err) end
                    return nil, tostring(err)
                end
                local item, err = unpack(vs, 2)
                if item then
                    n = n + 1
                    items[n] = item
                else
                    xwarn('@error', '@plain', err)
                end
            end
        end
        if n == nitems then return true end
        local fmt, err, errno = self:write(fname, items)
        if not fmt then return nil, err, errno end
        return true
    end
)


-------------------
-- Document parsing
--
-- @section

--- Make a shallow copy of a Pandoc AST element.
--
-- @tparam pandoc.AstElement elem A Pandoc AST element.
-- @treturn pandoc.AstElement The clone.
-- @fixme Not unit-tested.
--
-- @function elem_clone
if not pandoc.types or PANDOC_VERSION < {2, 15} then
    elem_clone = typed_args('table')(
        function (elem)
            if elem.clone then return elem:clone() end
            return copy(elem, false)
        end
    )
else
    elem_clone = typed_args('table|userdata')(
        function (elem)
            if elem.clone then return elem:clone() end
            local clone = {}
            for k, v in pairs(elem) do
                local t = type(v)
                if t == 'userdata' or t == 'table' then
                    if v.clone then clone[k] = v:clone()
                            else clone[k] = copy(v)
                    end
                end
            end
            assert(elem_type(elem) == 'Pandoc', 'expected a Pandoc document.')
            return Pandoc(clone.blocks, clone.meta)
        end
    )
end

do
    -- A mapping of types to their higher-order types.
    local super = {
        Meta = 'AstElement',
        MetaValue = 'AstElement',
        MetaBlocks = 'Meta',
        MetaBool = 'Meta',
        MetaInlines = 'Meta',
        MetaList = 'Meta',
        MetaMap = 'Meta',
        MetaString = 'Meta',
        Block = 'AstElement',
        BlockQuote = 'Block',
        BulletList = 'Block',
        CodeBlock = 'Block',
        DefinitionList = 'Block',
        Div = 'Block',
        Header = 'Block',
        HorizontalRule = 'Block',
        LineBlock = 'Block',
        Null = 'Block',
        OrderedList = 'Block',
        Para = 'Block',
        Plain = 'Block',
        RawBlock = 'Block',
        Values = 'Block',
        Inline = 'AstElement',
        Cite = 'Inline',
        Code = 'Inline',
        Emph = 'Inline',
        Image = 'Inline',
        LineBreak = 'Inline',
        Link = 'Inline',
        Math = 'Inline',
        Note = 'Inline',
        Quoted = 'Inline',
        RawInline = 'Inline',
        SmallCaps = 'Inline',
        SoftBreak = 'Inline',
        Space = 'Inline',
        Span = 'Inline',
        Str = 'Inline',
        Strikeout = 'Inline',
        Strong = 'Inline',
        Subscript = 'Inline',
        Superscript = 'Inline',
        Underline = 'Inline'
    }

    -- Get the type of list items, if all list are of the same type.
    --
    -- @tparam pandoc.List items Items.
    -- @treturn[1] string A Pandoc AST type.
    -- @treturn[2] nil `nil` if the given value is not a list.
    -- @treturn[2] string An error message.
    local function items_type (items, ...)
        local cnt = {}
        local n = 0
        while true do
            local i = n + 1
            local item = items[i]
            if item == nil then break end
            n = i
            local et, est = elem_type(item, ...)
            if not et or not est then break end
            cnt[est] = cnt[est] or 0 + 1
        end
        local st, ntypes = next(cnt)
        if st and n == ntypes then return st end
        return nil, 'not a list of Pandoc elements.'
    end

    -- Get the type of a Pandoc element (worker).
    --
    -- @tparam pandoc.AstElement el A Pandoc AST element.
    -- @treturn[1] string A type (e.g., 'Str').
    -- @treturn[2] nil `nil` if the given value is not a Pandoc AST element.
    -- @treturn[2] string An error message.
    --
    -- @function et_type
    local el_type
    if not pandoc.types or PANDOC_VERSION < {2, 15} then
        function el_type (el, ...)
            if type(el) == 'table' then
                -- This works even if elem.tag does not.
                local mt = getmetatable(el)
                if mt and mt.__type and mt.__type.name then
                    return mt.__type.name
                end

                -- Lists of similar AST elements.
                local lt = items_type(el, ...)
                if lt then return lt .. 's' end
            end
            return nil, 'not a Pandoc AST element.'
        end
    else
        -- @todo This works for the development version of Pandoc
        --       as of commit 60fc05e and is subject to change.
        --       See <https://github.com/jgm/pandoc/issues/7796>.
        local pandoc_type = pandoc.utils.type

        function el_type (el, ...)
            local t = type(el)
            if t == 'userdata' or t == 'table' then
                -- Use the tag, if there is one.
                if el.tag then return el.tag end

                -- Check if we can use pandoc.utils.type.
                if pandoc_type then
                    local pt = pandoc_type(el)
                    if
                        pt:match '^[A-Z]' and
                        pt ~= 'Meta'      and
                        pt ~= 'List'
                    then return pt end

                -- Lists of AST elements of the same type (e.g., 'Inlines').
                elseif t == 'table' then
                    local lt = items_type(el, ...)
                    if lt then return lt .. 's' end
                end

                -- If this point is reached, then there is no better way to
                -- determine whether an element is a Pandoc document.
                if
                    el.meta   and
                    el.blocks and
                    t == 'userdata'
                then return 'Pandoc' end
            end
            return nil, 'not a Pandoc AST element.'
        end
    end

    --- Get the type of a Pandoc AST element.
    --
    -- @tparam pandoc.AstElement elem A Pandoc AST element.
    -- @treturn[1] string A type (e.g., 'Str').
    -- @treturn[1] string|nil A super-type (e.g., 'Block' or 'Meta').
    -- @treturn[1] string|nil ⋮.
    -- @treturn[2] nil `nil` if the given value is not a Pandoc AST element.
    -- @treturn[2] string An error message.
    --
    -- @function elem_type
    function elem_type (elem, _seen)
        if     not _seen   then _seen = {}
        elseif _seen[elem] then return nil, 'cycle in data tree.'
        end
        _seen[elem] = true
        local et, err = el_type(elem, _seen)
        if not et then return nil, err end
        local ets = Values()
        while et do
            ets:add(et)
            et = super[et]
        end
        return unpack(ets)
    end
end

do
    -- Walk a Lua table.
    local function walk_table (tab, ...)
        for k, v in pairs(tab) do tab[k] = elem_walk(v, ...) end
    end

    --- Walk a *List AST element (e.g., `pandoc.OrderedList`).
    local function walk_list_elem (elem, ...)
        local content = elem.content
        for i = 1, #content do walk_table(content[i], ...) end
    end

    -- Walk a document.
    local function walk_doc (doc, ...)
        doc.meta = elem_walk(doc.meta, ...)
        walk_table(doc.blocks, ...)
    end

    -- Walking functions by Pandoc AST element type.
    local walkers = {
        Meta = walk_table,
        MetaBlocks = walk_table,
        MetaList = walk_table,
        MetaInlines = walk_table,
        MetaMap = walk_table,
        BulletList = walk_list_elem,
        OrderedList = walk_list_elem,
        Inlines = walk_table,
        Blocks = walk_table,
        Metas = walk_table,
        Pandoc = walk_doc
    }

    --- Walk an AST and apply a filter to matching elements.
    --
    -- Differs from Pandoc's walkers by:
    --
    -- * walking AST elements of any type (inluding documents and metadata),
    -- * walking the AST bottom-up,
    -- * *not* accepting the `traverse` keyword,
    -- * applying the filter to the given element itself,
    -- * allowing functions in the filter to return data of arbitrary types,
    -- * never modifying the original element, and
    -- * accepting 'AstElement' as type that matches any element.
    --
    -- @tparam pandoc.AstElement elem A Pandoc AST element.
    -- @tparam {string=func,...} filter A filter.
    -- @return Typically but not necessarily, a new Pandoc AST element.
    --
    -- @function elem_walk
    elem_walk = typed_args('*', 'table', '?table')(
        function (elem, filter, _seen)
            if not _seen then _seen = {} end
            assert(not _seen[elem], 'cycle in data tree.')
            local ets = {elem_type(elem)}
            local et = ets[1]
            if et then
                _seen[elem] = true
                elem = elem_clone(elem)
                local walker = walkers[et]
                if walker then
                    walker(elem, filter, _seen)
                elseif elem.content then
                    walk_table(elem.content, filter, _seen)
                end
                for i = 1, #ets do
                    local func = filter[ets[i]]
                    if func then
                        local new = func(elem)
                        if new ~= nil then elem = new end
                    end
                end
            elseif type(elem) == 'table' then
                _seen[elem] = true
                if elem.clone then elem = elem:clone()
                              else elem = copy(elem, false)
                end
                walk_table(elem, filter, _seen)
            end
            return elem
        end
    )
end

--- Collect bibliographic data.
--
-- Reads the `references` metadata field and every bibliography file.
--
-- @side May print error messages to STDERR.
--
-- @tparam pandoc.MetaMap meta A metadata block.
-- @treturn pandoc.List CSL items.
--
-- @function meta_sources
meta_sources = typed_args('table|userdata')(
    function (meta)
        local data = List()
        if not meta then return data end
        if meta.references then data:extend(meta.references) end
        if meta.bibliography then
            local fnames = opts_parse(meta, {
                name = 'bibliography',
                type = 'list'
            }).bibliography
            for i = 1, #fnames do
                -- luacheck: ignore err
                local fname, err = file_locate(fnames[i])
                if fname then
                    local items, err = biblio:read(fname)
                    if items then data:extend(items)
                             else xwarn('@error', '@plain', err)
                    end
                else
                    xwarn('@error', '@plain', err)
                end
            end
        end
        return data
    end
)

--- Collect the citation keys used in a document.
--
-- @side May print error messages to STDERR.
--
-- @tparam pandoc.Pandoc doc A document.
-- @bool[opt] undef Collect only undefind citation keys?
-- @treturn {string,...} Citation keys.
-- @treturn int The number of citation keys found.
--
-- @function doc_ckeys
doc_ckeys = typed_args('table|userdata', '?boolean')(
    function (doc, undef)
        local meta = doc.meta or {}
        local blocks = doc.blocks
        local ckeys = {}
        local filter = {
            Cite = function (cite)
                ckeys = update(ckeys, csl_items_ids(cite.citations))
            end
        }
        for k, v in pairs(meta) do
            if k ~= 'references' then elem_walk(v, filter) end
        end
        for i = 1, #blocks do
            pandoc.walk_block(blocks[i], filter)
        end
        if undef then
            for ckey in pairs(csl_items_ids(meta_sources(meta))) do
                ckeys[ckey] = nil
            end
        end
        return keys(ckeys)
    end
)


-----------------
-- Option parsing
-- @section

--- An option definition
--
-- @string name An option name.
-- @string[opt='string'] type A type to coerce the option's value to.
-- @func[opt] parse A parser.
-- @string[opt] prefix A prefix.
--
-- @caveats This table exists in documentation only.
-- @see opts_parse
-- @table Option

--- An option parser.
--
-- @see Options:new
-- @see Options:add
-- @see Options:parse
-- @object Options
-- @proto @{Values}
Options = Values()

--- Create a new option parser.
--
--    parser = Options:new{name = 'foo'}
--
-- is equivalent to:
--
--    parser = Options()
--    parser:add{name = 'foo'}
--
-- @tparam Option ... Options.
--
-- @see Options:add
-- @function Options:new
Options.new = typed_args('table', {
    name = 'string',
    type = '?string',
    parse = '?function',
    prefix = '?string'
})(Values.new)

--- Add an option to the parser.
--
-- @tparam Option ... Options.
--
-- @usage
-- parser = Options()
-- parser:add{
--     name = 'bar',
--     type = 'number',
--     parse = function (x)
--         if x < 1 return return nil, 'not a positive number.' end
--         return x
--     end
-- }
--
-- @see opts_parse
-- @see Options:parse
-- @function Options:add
Options.add = typed_args('table', {
    name = 'string',
    type = '?string',
    parse = '?function',
    prefix = '?string'},
'...')(Values.add)

--- Read configuration options from a metadata block.
--
-- @tparam pandoc.MetaMap meta A metadata block.
-- @treturn tab A mapping of option names to values.
--
-- @usage
-- > meta = pandoc.MetaMap{
-- >     ['foo-bar'] = pandoc.MetaInlines(pandoc.List{
-- >         pandoc.Str "0123"
-- >     })
-- > parser = Options()
-- > parser:add{
-- >     name = 'bar',
-- >     type = 'number',
-- >     parse = function (x)
-- >         if x < 1 return return nil, 'not a positive number.' end
-- >         return x
-- >     end
-- > }
-- > opts = parser:parse(meta)
-- > opts.bars
-- 123
-- > type(opts.bar)
-- number
--
-- @see opts_parse
-- @see Options:add
-- @function Options:parse
Options.parse = typed_args('table', 'table|userdata')(
    function (self, meta)
        return opts_parse(meta, unpack(self))
    end
)

do
    -- @todo This works for the development version of Pandoc
    --       as of commit 60fc05e and is subject to change.
    --       See <https://github.com/jgm/pandoc/issues/7796>.
    local pandoc_type = pandoc.utils.type

    -- A mapping of configuration value types to parers.
    local converters = {}

    -- Convert a configuration value to a type.
    --
    -- @param val A value.
    -- @string[opt='string'] type A type declaration.
    --  See @{opts_parse} for the grammar.
    -- @return[1] A value of the given type.
    -- @treturn[2] nil `nil` if the value cannot be converted.
    -- @treturn[2] string An error message.
    -- @raise An error if a type declaration cannot be parsed.
    local function convert (val, decl)
        if not decl then decl = 'string' end
        local head, tail = decl:match '^%s*(%l+)%s*<?%s*([%l<>%s]-)%s*>?%s*$'
        if not head then error(format('cannot parse type "%s".', decl), 3) end
        local conv = converters[head]
        if not conv then error(head .. ': no such type.', 3) end
        return conv(val, tail or 'string')
    end

    -- Convert a value to a Lua string.
    --
    -- @param val A value.
    -- @treturn[1] string A string.
    -- @treturn[2] nil `nil` if the value cannot be converted to a string.
    -- @treturn[2] string An error message.
    -- @todo Test whether stringify could do all the work.
    function converters.string (val)
        local t = type(val)
        if t == 'string' then
            return val
        elseif t == 'number' then
            return tostring(val)
        elseif elem_type(val) then
            local ok, str = pcall(stringify, val)
            if ok and str ~= '' then return str end
        end
        return nil, 'not a string or empty.'
    end

    -- Convert a value to a Lua number.
    --
    -- @param val A value.
    -- @treturn[1] number A number.
    -- @treturn[2] nil `nil` if the value cannot be converted to a number.
    -- @treturn[2] string An error message.
    function converters.number (val)
        if type(val) == 'number' then return val end
        local ok = true
        if elem_type(val) then ok, val = pcall(stringify, val) end
        if ok then
            local num = tonumber(val)
            if num then return num end
        end
        return nil, 'not a number.'
    end

    -- Convert values to lists.
    --
    -- Tables are passed through as is.
    --
    -- @param val A value or list of values.
    -- @treturn pandoc.List A list of values.
    function converters.list (val, decl)
        if decl == '' then decl = 'string' end
        local function conv (v) return convert(v, decl) end
        local t = type(val)
        if t == 'userdata' or t == 'table' then
            if pandoc_type then
                local pt = pandoc_type(val)
                if pt == 'List' then return val:map(conv) end
            else
                local et = elem_type(val)
                if et == 'MetaList' then
                    return val:map(conv)
                elseif t == 'table' and not et then
                    return List(val):map(conv)
                end
            end
        end
        return List{conv(val)}
    end

    --- Read configuration options from a metadata block.
    --
    -- <h3>Mapping of option names to metadata fieldnames:</h3>
    --
    -- The name of the metadata field that is looked up by @{Options:parse} is
    -- the name of the option with underscores replaced by dashes. If the
    -- option has a prefix, then the fieldname is prefixed with that prefix
    -- and a dash *after* underscores have been replaced with dashes.
    --
    -- In Lua:
    --
    --    fieldname = name:gsub('_', '-')
    --    if prefix then fieldname = prefix .. '-' .. fieldname end
    --
    -- <h3>Type declaration grammar:</h3>
    --
    -- Configuration values can be of one of three types:
    --
    -- * 'number'
    -- * 'string'
    -- * 'list'
    --
    -- If you declare an option to be of the scalar types 'number' or
    -- 'string', its value is required to be of the Lua type of the
    -- same name. Values are converted automatically if possible.
    --
    -- If you declare an option to be of the type 'list', its value is
    -- required to be a `pandoc.List`. If a scalar is encountered where
    -- a list was expected, the value is wrapped in a single-item list.
    --
    -- The items of a list must all be of the same type, which you declare by
    -- appending '<*T*>' to the literal 'list', where *T* is either the name
    -- of a scalar type or another list declaration and defaults to 'string'.
    --
    -- In [Extended Backus-Naur Form](https://en.wikipedia.org/wiki/EBNF):
    --
    -- > Scalar = ( 'number' | 'string' )
    -- >
    -- > List = 'list', [ '<', ( scalar | list ), '>' ]
    --
    -- No type checks or conversions are performed for `nil`.
    --
    -- <h3>Parse protocol:</h3>
    --
    -- A parser is a function that takes the converted value and
    -- returns a new one or `nil` and an error message.
    --
    -- Parsers are not called for `nil`.
    --
    -- @tparam pandoc.MetaMap meta A metadata block.
    -- @tparam Option ... Options.
    -- @treturn tab A mapping of option names to values.
    --
    -- @usage
    -- > meta = pandoc.MetaMap{
    -- >     ['foo-bar'] = pandoc.MetaInlines(pandoc.List{
    -- >         pandoc.Str "0123"
    -- >     })
    -- > opts = opts_parse(meta, {
    -- >     name = 'bar',
    -- >     type = 'number',
    -- >     parse = function (x)
    -- >         if x < 1 return return nil, 'not a positive number.' end
    -- >         return x
    -- >     end
    -- > })
    -- > opts.bars
    -- 123
    -- > type(opts.bar)
    -- number
    --
    -- @see Options
    -- @function opts_parse
    opts_parse = typed_args('table|userdata', {
        name = 'string',
        type = '?string',
        parse = '?function',
        prefix = '?string'
    }, '...')(
        function (meta, ...)
            local opts = {}
            local defs = pack(...)
            if not meta or defs.n == 0 then return opts end
            for i = 1, defs.n do
                local def = defs[i]
                local key = def.name:gsub('_', '-')
                if def.prefix then key = def.prefix .. '-' .. key end
                local val = meta[key]
                if val ~= nil then
                    local err
                    for _, func in pairs{convert, def.parse} do
                        if not func then break end
                        val, err = func(val, def.type)
                        if not val then xerror(key .. ': ' .. err) end
                    end
                    opts[def.name] = val
                end
            end
            return opts
        end
    )
end


--------------------
-- Zotero connectors
-- @section

--- A case-insensitive namespace for connector prototypes.
--
-- <h3>Connector protocol:</h3>
--
-- A connector prototype *must* provide two methods:
--
-- * `new`: Called to create handles.
--   Must have the same function signature as @{Object:new} and
--   return `nil` and an error message if the handle cannot be created.
--
-- * `fetch`: Called to fetch bibliographc data. Must take a citation key and
--   return either a CSL item or `nil` and an error message.
--
-- Connector prototypes may register configuration settings by providing
-- an `options` property that points to an @{Options} object. That object's
-- @{Options:parse} method is then called with the document's metadata block
-- as argument and whatever it returns is passed on to `new`.
connectors = setmetatable({}, ignore_case)

--- Interface to [zotxt](https://github.com/egh/zotxt).
--
-- @usage
-- handle = connectors.Zotxt:new()
-- item = handle:fetch 'DoeWord2020'
--
-- @object connectors.Zotxt
-- @proto @{Object}
connectors.Zotxt = Object()

--- Zotero options.
--
-- Defines `zotero-citekey-types`.
-- See the [manual](#content) for details.
--
-- @object connectors.Zotxt.options
-- @proto @{Options}.
connectors.Zotxt.options = Options:new{
    prefix = 'zotero',
    name = 'citekey_types',
    type = 'list'
}

--- Types of citation keys to expect.
--
-- `pandoc.List` of @{string}s.
-- For example, `pandoc.List{'betterbibtexkey', 'easykey'}`.
connectors.Zotxt.citekey_types = List{
    'betterbibtexkey',  -- Better BibTeX citation key
    'easykey',          -- zotxt easy citekey
    'key',              -- Zotero item ID
}

do
    -- URL of the endpoint to look up items at.
    local items_url = 'http://localhost:23119/zotxt/items'

    --- Fetch a CSL item via zotxt.
    --
    -- @side May re-order the elements of @{connectors.Zotxt.citekey_types}.
    --
    -- @string ckey A citation key (e.g., `'doe:2020word'`, `'DoeWord2020'`).
    -- @treturn[1] table A CSL item.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    -- @raise See @{http_get}.
    --
    -- @function connectors.Zotxt:fetch
    connectors.Zotxt.fetch = typed_args({citekey_types = 'table'}, 'string')(
        function (self, ckey)
            local ckey_types = self.citekey_types
            local err = nil
            for i = 1, #ckey_types do
                -- zotxt supports searching for multiple citation keys at once,
                -- but if a single one cannot be found, it replies with a
                -- cryptic error message (for Easy Citekeys) or an empty
                -- response (for Better BibTeX citation keys).
                local ok, mt, str = pcall(url_query, items_url,
                                          {[ckey_types[i]] = ckey})
                xassert(ok, 'failed to connect to Zotero desktop client.')
                if not mt or mt == '' or not str or str == '' then
                    err = ckey .. ': zotxt response is empty.'
                elseif not mt:match ';%s*charset="?[Uu][Tt][Ff]%-?8"?%s*$' then
                    err = ckey .. ': zotxt response is not encoded in UTF-8.'
                else
                    local data = csl_json_parse(str)
                    if data then
                        local n = #data
                        if n == 1 then
                            if i ~= 1 then
                                ckey_types[1], ckey_types[i] =
                                ckey_types[i], ckey_types[1]
                            end
                            local item = data[1]
                            item.id = ckey
                            return item
                        end
                        if n == 0 then err = ckey .. ': no matches.'
                                  else err = ckey .. ': too many matches.'
                        end
                    else
                        err = ckey .. ': cannot parse Zotero response: ' .. str
                    end
                end
            end
            return nil, err
        end
    )
end

--- Interface to [Zotero's Web API](https://www.zotero.org/support/dev/web_api)
--
-- @string[opt] api_key A Zotero Web API key.
-- @number[opt] user_id A Zotero user ID.
-- @tparam[opt] {number,...} groups Zotero groups to search in.
-- @tparam[opt] {number,...} public_groups Public Zotero groups to search in.
--
-- @usage
-- handle = connectors.ZoteroWeb:new{api_key = 'a0Bc1De2Fg3Hi4Jk5Lm6No7'}
-- item = handle:fetch 'DoeWord2020'
--
-- @object connectors.ZoteroWeb
-- @proto @{connectors.Zotxt}
connectors.ZoteroWeb = connectors.Zotxt()

--- Types of citation keys to expect.
--
-- See @{connectors.Zotxt.citekey_types} for details
-- and @{citekey:guess_terms} for caveats.
connectors.ZoteroWeb.citekey_types = List {
    'key',              -- Zotero item IDs
    'easykey',          -- zotxt Easy Citekey
    'betterbibtexkey',  -- Better BibTeX citation key
}

--- Zotero Web API options.
--
-- Defines:
--
--  * `zotero-api-key`
--  * `zotero-user-id`
--  * `zotero-groups`
--  * `zotero-public-groups`
--
-- See the [manual](#content) for details.
--
-- @object connectors.ZoteroWeb.options
-- @proto @{connectors.Zotxt.options}.
connectors.ZoteroWeb.options = connectors.Zotxt.options:new(
    {prefix = 'zotero', name = 'api_key'},
    {prefix = 'zotero', name = 'user_id', type = 'number'},
    {prefix = 'zotero', name = 'groups', type = 'list<number>'},
    {prefix = 'zotero', name = 'public_groups', type = 'list<number>'}
)

do
    -- Shorthands.
    local len = utf8.len
    local decode = json.decode

    -- Zotero Web API base URL.
    local base_url = 'https://api.zotero.org'

    -- URL template for user ID lookups.
    local user_id_url = base_url .. '/keys/${api_key}'

    -- URL template for group membership lookups.
    local groups_url = base_url .. '/users/${user_id}/groups'

    -- User prefix.
    local user_prefix = '/users/${user_id}'

    -- Group prefix.
    local group_prefix = '/groups/${group_id}'

    -- URL template for item lookups.
    local items_url = base_url .. '${prefix}/items/${id}'

    --- Metatable for Zotero Web API connectors.
    connectors.ZoteroWeb.mt = getmetatable(connectors.ZoteroWeb)

    --- Delegate to the Zotero Web API interface.
    --
    -- @see delegate_with_getters
    -- @function connectors.ZoteroWeb.mt.__call
    connectors.ZoteroWeb.mt.__call = delegate_with_getters

    --- Getters for Zotero Web API connectors.
    --
    -- @see getterify
    connectors.ZoteroWeb.mt.getters = {}

    --- Get the user ID for the given API key.
    --
    -- @tparam connectors.ZoteroWeb obj A Zotero Web API handle.
    -- @treturn string A Zotero user ID.
    -- @raise
    --
    -- * @{string}: If the `api_key` field is not set.
    -- * @{Error}: If the Zotero Web API could not be reached,
    --   (see @{http_get} for details), the API's response cannot be parsed,
    --   or no user ID could be found for the given Zotero API key.
    --
    -- @function connectors.ZoteroWeb.mt.getters.user_id
    connectors.ZoteroWeb.mt.getters.user_id = typed_args('table')(
        function (obj)
            -- luacheck: ignore err
            assert(obj.api_key, 'no Zotero API key given.')
            local ep = vars_sub(user_id_url, obj)
            local str, err = obj.query(ep, {v = 3})
            if str then
                local ok, data = pcall(decode, str)
                if not ok then
                    err = 'cannot parse response: ' .. str
                else
                    local user_id = data.userID
                    if not user_id then
                        err = format('no user for API key %s.', obj.api_key)
                    else
                        obj.user_id = user_id
                        return user_id
                    end
                end
            end
            xerror('Zotero user ID lookup: ' .. err)
        end
    )

    --- Get the groups the user is a member of.
    --
    -- @tparam connectors.ZoteroWeb obj A Zotero Web API handle.
    -- @treturn {string,...} Zotero group IDs.
    -- @raise
    --
    --  * @{string}: If the `api_key` field is not set,
    --  * @{Error}: If the Zotero Web API could not be reached
    --    (see @{http_get} for details) or the API's response
    --    cannot be parsed.
    --
    -- @function connectors.ZoteroWeb.mt.getters.groups
    connectors.ZoteroWeb.mt.getters.groups = typed_args('table')(
        function (obj)
            -- luacheck: ignore err
            assert(obj.api_key, 'no Zotero API key given.')
            local ep = vars_sub(groups_url, obj)
            local str, err = obj.query(ep, {v = 3, key = obj.api_key})
            if str then
                local ok, data = pcall(decode, str)
                if not ok then
                    err = 'cannot parse response: ' .. str
                else
                    local groups = Values()
                    for i = 1, #data do
                        if data[i] and data[i].data and data[i].data.id then
                            groups:add(data[i].data.id)
                        end
                    end
                    obj.groups = groups
                    return groups
                end
            end
            xerror('Zotero groups lookup: ' .. err)
        end
    )

    --- Retrieve data from the Zotero Web API.
    --
    -- @string ep An endpoint URL.
    -- @tparam {string=string,...} params Request parameters.
    -- @treturn[1] string The response of the Zotero Web API.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    -- @raise See @{http_get}.
    --
    -- @see url_query
    -- @function connectors.ZoteroWeb.query
    -- @fixme Not unit-tested.
    connectors.ZoteroWeb.query = typed_args('string', '?table')(
        function (ep, params)
            local ok, mt, str = pcall(url_query, ep, params)
            xassert(ok, 'failed to connect to Zotero Web API.')
            if not mt or mt == '' then
                return nil, 'Zotero response declares no MIME type.'
            elseif not str or str == '' then
                return nil, 'Zotero response is empty.'
            elseif mt:match '%f[%a]json%f[%A]' then
                return str
            elseif not mt:match '^text/' then
                local err = 'Zotero response is of unexpected MIME type %s.'
                return nil, err:format(mt)
            elseif not mt:match ';%s*charset="?[Uu][Tt][Ff]%-?8"?%s*$' then
                return nil, 'Zotero response is not encoded in UTF-8.'
            end
            return nil, 'Zotero fetch error: ' .. str
        end
    )

    --- Iterate over item endpoint URLs.
    --
    -- @string[opt] id A Zotero item ID.
    -- @treturn func A *stateful* iterator.
    --
    -- @function connectors.ZoteroWeb:endpoints
    connectors.ZoteroWeb.endpoints = typed_args('table', '?string')(
        function (self, id)
            if not id then id = '' end
            local groups, ngroups
            local i = -1
            return function ()
                i = i + 1
                if i == 0 then
                    if self.api_key then
                        return vars_sub(items_url, {
                            prefix = user_prefix,
                            user_id = self.user_id,
                            id = id
                        })
                    end
                else
                    if not groups then
                        groups = List()
                        if self.api_key then
                            groups:extend(self.groups)
                        end
                        if self.public_groups then
                            groups:extend(self.public_groups)
                        end
                        ngroups = #groups
                    end
                    if i > ngroups then return end
                    return vars_sub(items_url, {
                        prefix = group_prefix,
                        group_id = groups[i],
                        id = id
                    })
                end
            end
        end
    )

    --- Search items by their author, publication year, and title.
    --
    -- @caveats Does *not* correct Zotero's CSL JSON export.
    --
    -- @string ... Search terms.
    -- @treturn[1] tab CSL items that match the given search terms.
    -- @treturn[2] nil `nil` if no items were found or an error occurred.
    -- @treturn[2] string An error message.
    -- @treturn[2] An error message.
    -- @raise See @{connectors.ZoteroWeb.mt.getters.user_id} and
    --  @{connectors.ZoteroWeb.mt.getters.groups}.
    --
    -- @function connectors.ZoteroWeb:search
    connectors.ZoteroWeb.search = typed_args(
        {
            endpoints = 'function',
            query = 'function'
        },
        'string',
        '?string',
        '...'
    )(
        function (self, ...)
            local q = concat({...}, '+')
            local params = {v = 3, key = self.api_key,
                            q = q, qmode = 'titleCreatorYear',
                            format ='csljson', itemType='-attachment'}
            for ep in self:endpoints() do
                -- luacheck: ignore err
                local str, err = self.query(ep, params)
                if not str then return nil, err end
                local data, err = csl_json_parse(str)
                if not data then return nil, err end
                local items = data.items
                if items and #items > 0 then return items end
            end
            return nil, 'no matches.'
        end
    )

    --- Look up a CSL item by its Zotero ID.
    --
    -- @string id A Zotero item ID.
    -- @treturn[1] tab A CSL item.
    -- @treturn[2] nil `nil` if no or more than one item has been found.
    -- @treturn[2] string An error message.
    -- @raise See @{connectors.ZoteroWeb.mt.getters.user_id} and
    --  @{connectors.ZoteroWeb.mt.getters.groups}.
    --
    -- @function connectors.ZoteroWeb:lookup
    connectors.ZoteroWeb.lookup = typed_args({
        endpoints = 'function',
        query = 'function'
    }, 'string')(
        function (self, id)
            local params = {v = 3, key = self.api_key,
                            format ='csljson', itemType='-attachment'}
            for ep in self:endpoints(id) do
                local str = self.query(ep, params)
                if str then
                    local data, err = csl_json_parse(str)
                    if not data then return nil, err end
                    local items = data.items
                    if items then
                        local n = #items
                        if n == 1 then
                            local item = items[1]
                            item.id = id
                            return csl_item_add_extras(item)
                        elseif n > 1 then
                            return nil, format('item ID %s: not unique.', id)
                        end
                    end
                end
            end
            return nil, 'no matches.'
        end
    )

    --- Fetch a CSL item from the Zotero Web API.
    --
    -- @side
    --
    -- Search terms for citation keys are printed to STDERR
    -- if the user has requested verbose output.
    --
    -- @string ckey A citation key (e.g., `'doe:2020word'`, `'DoeWord2020'`).
    -- @treturn[1] table A CSL item.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    -- @raise See @{connectors.ZoteroWeb.mt.getters.user_id} and
    --  @{connectors.ZoteroWeb.mt.getters.groups}.
    --
    -- @function connectors.ZoteroWeb:fetch
    connectors.ZoteroWeb.fetch = typed_args({
        citekey_types = 'table',
        lookup = 'function',
        search = 'function'
    }, 'string')(
        function (self, ckey)
            -- luacheck: ignore err
            assert(ckey ~= '', 'citation key is the empty string.')
            if
                self.citekey_types:includes 'key' and
                len(ckey) == 8                    and
                ckey:match '^[%u%d]+$'
            then return self:lookup(ckey) end
            local terms, err = citekey:guess_terms(ckey, self.citekey_types)
            if not terms then return nil, err end
            xwarn('@info', '${ckey}: searching for: ',
                  '@plain', concat(terms, ', '))
            local items, err = self:search(unpack(terms))
            if not items then return nil, ckey .. ': ' .. err end
            local n = #items
            if n == 0 then
                return nil, ckey .. ': no matches.'
            elseif n > 1 then
                items = csl_items_filter_by_ckey(items, ckey)
                if not items or items.n == 0 then
                    return nil, ckey .. ': too many matches.'
                elseif items.n > 1 then
                    return nil, format('citation key %s: not unique.', ckey)
                end
            end
            local item = items[1]
            item.id = ckey
            return csl_item_add_extras(item)
        end
    )
end


-------
-- Main
--
-- @section

--- Add bibliographic data to a bibliography file.
--
-- Updates the bibliography file as needed and adds its to the
-- `bibliography` metadata field. Interpretes relative filenames
-- as relative to the directory of the first input file passed
-- to **pandoc**, or, if no input files were given, as relative
-- to the current working directory.
--
-- @caveats @{file_write}.
-- @side May print error messages to STDERR.
--
-- @string fname A filename for the bibliography file.
-- @tparam connectors.Zotxt|connectors.ZoteroWeb handle A Zotero handle.
-- @tparam pandoc.Pandoc doc A Pandoc document.
-- @treturn[1] pandoc.Meta An updated metadata block.
-- @treturn[2] nil `nil` if nothing was done or an error occurred.
-- @treturn[2] string An error message, if applicable.
-- @raise See @{connectors.Zotxt} and @{connectors.ZoteroWeb}.
--
-- @function add_biblio
add_biblio = typed_args('string', 'table', 'table|userdata')(
    function (fname, handle, doc)
        local ckeys = doc_ckeys(doc, true)
        if #ckeys == 0 then return end
        local meta = doc.meta
        if not path_is_abs(fname) then fname = path_join(wd(), fname) end
        local ok, err = biblio:update(handle, fname, ckeys)
        if not ok then return nil, err end
        local fnames = opts_parse(meta, {
            name = 'bibliography',
            type = 'list'
        }).bibliography or List()
        fnames:insert(fname)
        meta.bibliography = fnames
        return meta
    end
)

--- Add bibliographic data to the `references` metadata field.
--
-- @side May print error messages to STDERR.
--
-- @tparam connectors.Zotxt|connectors.ZoteroWeb handle A Zotero handle.
-- @tparam pandoc.Pandoc doc A Pandoc document.
-- @treturn[1] table An updated metadata block.
-- @treturn[2] nil `nil` if nothing was done or an error occurred.
-- @treturn[2] string An error message, if applicable.
-- @raise See @{connectors.Zotxt} and @{connectors.ZoteroWeb}.
--
-- @function add_refs
add_refs = typed_args('table', 'table|userdata')(
    function (handle, doc)
        local ckeys = doc_ckeys(doc, true)
        local meta = doc.meta
        if #ckeys == 0 then return end
        if not meta.references then meta.references = MetaList({}) end
        local n = #meta.references
        for i = 1, #ckeys do
            local ok, ret, err = pcall(handle.fetch, handle, ckeys[i])
            if     not ok then return nil, tostring(ret)
            elseif ret    then n = n + 1
                               meta.references[n] = csl_item_to_meta(ret)
                          else xwarn('@error', '@plain', err)
            end
        end
        return meta
    end
)

do
    local parser = Options:new(
        {prefix = 'zotero', name = 'bibliography'},
        {
            prefix = 'zotero',
            name = 'connectors',
            type = 'list',
            parse = function (names)
                local conns = Values()
                for i = 1, #names do
                    local name = names[i]
                    if not name:match '^%a[%w_]+$' then
                        return nil, name .. ': not a connector name.'
                    end
                    local conn = connectors[name]
                    if not conn then
                        return nil, name .. ': no such connector.'
                    elseif not type_match(conn, {
                        new = 'function',
                        fetch = 'function'
                    }) then
                        return nil, name .. ': connector violates protocol.'
                    end
                    conns:add(conn)
                end
                return conns
            end
        }
    )

    --- Collect citations and add bibliographic data to the document.
    --
    -- See the [manual](#content) for details.
    --
    -- @side May print error messages to STDERR.
    --
    -- @tparam pandoc.Pandoc doc A document.
    -- @treturn[1] pandoc.Pandoc The document with bibliographic data added.
    -- @treturn[2] nil `nil` if nothing was done or an error occurred.
    -- @raise See @{connectors.Zotxt} and @{connectors.ZoteroWeb}.
    function main (doc)
        local opts = parser:parse(doc.meta)

        local handles = Values()

        if not opts.connectors or #opts.connectors == 0 then
            for _, conn in sorted(connectors, order{'zotero'}) do
                local args
                if conn.options then args = conn.options:parse(doc.meta) end
                local ok, handle = pcall(conn.new, conn, args)
                if ok then handles:add(handle) end
            end
        else
            for i = 1, #opts.connectors do
                local conn = opts.connectors[i]
                local args
                if conn.options then args = conn.options:parse(doc.meta) end
                local handle, err = conn:new(args)
                if not handle then xerror(err) end
                handles:add(handle)
            end
        end

        local add_sources
        if opts.bibliography then
            function add_sources (...)
                return add_biblio(opts.bibliography, ...)
            end
        else
            add_sources = add_refs
        end

        local chg = false
        for i = 1, handles.n do
            local meta, err = add_sources(handles[i], doc)
            if meta then
                doc.meta = meta
                chg = true
            elseif err then
                xwarn('@error', '@plain', err)
            end
        end
        if chg then return doc end
    end
end


-- Returning the whole script, rather than only a list of mappings of
-- Pandoc data types to functions, allows to do unit testing.

M[1] = {Pandoc = function (doc)
    -- No special error handling in debugging mode.
    if DEBUG then return main(doc) end

    local stack_trace
    local function traceback (...)
        stack_trace = debug.traceback(...)
        return ...
    end

    -- Catch errors, users should not be bothered with stack traces.
    local vs = pack(xpcall(main, traceback, doc))
    local ok, err = unpack(vs, 1, 2)
    if ok then return unpack(vs, 2) end

    -- An error object signifies an 'ordinary' run-time error.
    if type(err) == 'table' then
        xwarn('@error', '@plain', err)
        return
    end

    -- This point should not be reached.
    xerror([[
=================================================
Sorry, you have found a bug. Please report it at:
-------------------------------------------------
https://github.com/odkr/${repo|e}/issues/new?title=${title|e}&body=${body|e}
=================================================
]] .. err:gsub('\r?\n', EOL), {
        repo = SCRIPT_NAME,
        title = 'v${version} - run-time error "${err}"',
        body = [[---
Stack trace:
> ${stack_trace}
---
Pandoc version: ${pandoc_version}
OS type: ${os_type}]],
        err = err,
        stack_trace = stack_trace,
        version = VERSION,
        os_type = OS_TYPE,
        pandoc_version = PANDOC_VERSION,
        e = uri_escape
    })
end}

return M