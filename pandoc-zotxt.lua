---
-- SYNOPSIS
-- ========
--
-- **pandoc** **-L** *pandoc-zotxt.lua* **-C**
--
-- DESCRIPTION
-- ===========
--
-- **pandoc-zotxt.lua** is a Lua filter for Pandoc that looks up bibliographic
-- data for citations in Zotero and adds that data to the "references"
-- metadata field or to a bibliography file, where Pandoc can pick it up.
--
-- Cite your sources using so-called "Better BibTeX citation keys" (provided
-- by Better BibTeX for Zotero) or "Easy Citekeys" (provided by zotxt) and
-- then tell **pandoc** to filter your document through **pandoc-zotxt.lua**
-- before processing citations. That's all there is to it.
--
-- For example:
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     See @DoeTitle2020 for details.
--     EOF
--
-- If the "references" metadata field or a bibliography file already contains
-- bibliographic data for a citation, that citation will *not* be looked up.
--
-- CONNECTING TO ZOTERO
-- ====================
--
-- Desktop client
-- --------------
--
-- By default, bibliographic data is fetched from the Zotero desktop client,
-- which must be running when you invoke **pandoc**. This is the faster,
-- easier, and less error-prone way to fetch citations from Zotero. It
-- requires zotxt and BetterBibTeX for Zotero.
--
-- Web API
-- -------
--
-- Bibliographic data can also be fetched from the Zotero Web API.
--
-- To fetch data from your personal library, create a Zotero API key and set
-- the "zotero-api-key" metadata field to that key:
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     ---
--     zotero-connectors: zoteroweb
--     zotero-api-key: MO2GHxbkLnWgCqPtpoewgwIl
--     ...
--     Look up @DoeTitle2020 via the Zotero Web API.
--     EOF
--
-- You can also fetch bibliographic data from public Zotero groups. To do so,
-- list the IDs of those groups in the metadata field "zotero-public-groups";
-- fetching data from public groups does not require an API key.
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     ---
--     zotero-connectors: zoteroweb
--     zotero-public-groups: 4532986
--     ...
--     Look up @DoeTitle2020 in the Zotero group with the ID 4532986.
--     EOF
--
-- The Zotero Web API does *not* allow to search for citation keys other than
-- Zotero item IDs. Therefore, BetterBibTeX citation keys and Easy Citekeys
-- have to be translated into author names, title keywords, and publication
-- years; Better BibTeX citation keys are split up at uppercase letters and
-- the first of each series of digits ("DoeTitle2020" becomes "Doe", "Title",
-- "2020"). Easy Citekeys are split up at the first colon and the last digit
-- ("doe:2020title" becomes "doe", "2020", "title"). Citation keys that cannot
-- be translated into at least two search terms are ignored.
--
-- If a search yields two or more items, you need to disambiguate them. If you
-- use BetterBibTeX, you may want to set its citation key format to something
-- along the lines of "[auth][year][shorttitle3_3]" to make collisions less
-- likely. Alternatively, you can add an item's citation key to its "extra"
-- field in Zotero. Zotero's "extra" field is a list of CSL key-value pairs;
-- keys and values are separated by colons (":"), key-value pairs by
-- linefeeds. Use either the key "Citation key" or the key "Citekey" to add a
-- citation key (e.g., "Citation key: DoeTitle2020"); case is insignificant.
-- If you use Better BibTeX for Zotero, you can add the citation key it has
-- generated by 'pinning' it.
--
-- Support for accessing group libraries via the Zotero Web API is limited.
-- They are only searched if no item in your personal library matches.
-- Morever, the "extra" field of items in group libraries is ignored.
--
-- CACHING SOURCES WITH A BIBLIOGRAPHY FILE
-- ========================================
--
-- Bibliographic data can be added to a bibliography file, rather than to the
-- "references" metadata field. This speeds up subsequent processing, because
-- data that has already been fetched from Zotero need not be fetched again.
--
-- To use such a bibliography file, set the "zotero-bibliography" metadata
-- field to a filename. If that filename is relative, it is interpreted as
-- being relative to the directory of the first input file or, if no input
-- files were given, the current working directory.
--
-- The "zotero-bibliography" metadata field may contain environment variables.
-- Variable names must be enclosed in `${...}`. They are replaced with the
-- value of that variable (e.g., `${HOME}` will be replaced with your home
-- directory). Moreover, any series of *n* dollar signs is replaced with *n*�
-- – 1 dollar signs, so that you can escape them should they occur in a
-- filename.
--
-- The format of the file is determined by its filename ending.
--
-- | **Ending** | **Format** |
-- | ---------- | ---------- |
-- | `.bib`     | BibLaTeX   |
-- | `.bibtex`  | BibTeX     |
-- | `.json`    | CSL JSON   |
-- | `.yaml`    | CSL YAML   |
--
-- Support for BibLaTeX and BibTeX files requires Pandoc v2.17 or later. CSL
-- is preferable to BibLaTeX and BibTeX.
--
-- The bibliography file is added to the "bibliography" metadata field
-- automatically; if that field already contains bibliography files, they take
-- priority.
--
-- Data is only ever added to the bibliography file, never updated or deleted.
-- However, if you delete the file, it will be regenerated from scratch.
--
-- For example:
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     ---
--     zotero-bibliography: ${HOME}/foo/bibliography.json
--     ...
--     See @DoeTitle2020 for details.
--     EOF
--
-- CITATION KEY TYPES
-- ==================
--
-- You can use citation keys of multitple types:
--
-- | **Name**          | **Type**                   | **Example**   |
-- | ----------------- | -------------------------- | ------------- |
-- | `betterbibtexkey` | Better BibTeX citation key | DoeTitle2020  |
-- | `easykey`         | Easy Citekey               | doe:2020title |
-- | `key`             | Zotero item ID             | A1BC23D4      |
--
-- You can force citation keys to be interpreted as being of a particular type
-- by setting the "zotero-citekey-types" metadata field:
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     ---
--     zotero-citekey-types: betterbibtexkey
--     ...
--     Force @DoeTitle to be treated as BetterBibTeX citation key.
--     EOF
--
-- This is useful if a Better BibTeX citation key is misinterpreted as being
-- an Easy Citekey, or vica vera.
--
-- CONFIGURATION
-- =============
--
-- You can control how bibligraphic data is fetched by setting the following
-- metadata fields:
--
-- * `zotero-api-key`: A Zotero API key. Only applies to the '[Web
-- API](#web-api)'.
--
-- * `zotero-bibliography`: A bibliography filename. See '[Caching sources
-- with a bibliography file](#caching-sources-with-a-bibliography-file)' above.
--
-- * `zotero-citekey-types`: A list of citation key types. Citation keys are
-- interpreted to be of the listed types only. See '[Citation key
-- types](#citation-key-types)' above.
--
-- * `zotero-connectors`: One or more ways to connect to Zotero:
--
--   | **Key**   | **Fetch data from**   |
--   | --------- | --------------------- |
--   | zotxt     | Zotero desktop client |
--   | zoteroweb | Zotero Web API        |
--
--   Data is fetched via the given connectors in the order in which they are
--   given. If bibliographic data for a source can be fetched via an earlier
--   connector, it is *not* searched for via later ones. By default, data is
--   first searched for using zotxt and then using the Web API.
--
-- * `zotero-groups`: A list of Zotero group IDs. Only the given groups are
-- searched. By default, all groups you are a member of are searched. Only
-- applies to the '[Web API](#web-api)'.
--
-- * `zotero-public-groups`: A list of Zotero group IDs. The given groups are
-- searched in addition to non-public groups. Only applies to the '[Web
-- API](#web-api)'.
--
-- * `zotero-user-id`: A Zotero user ID. Looked up automatically if not given.
-- Only applies to the '[Web API](#web-api)'.
--
-- If a metadata field expects a list of values, giving a single item is the
-- same as giving a single-item list. For example:
--
--     pandoc -L pandoc-zotxt.lua -C <<EOF
--     ---
--     zotero-citekey-types: betterbibtexkey
--     ...
--     See @DoeTitle2020 for details.
--     EOF
--
-- KNOWN ISSUES
-- ============
--
-- **pandoc-zotxt.lua** creates a temporary file when it adds bibliographic
-- data to a bibliography file. If Pandoc exits because it catches a signal
-- (e.g., because you press `Ctrl`-`c`), this file will *not* be deleted. This
-- is a bug in Pandoc (issue #7355) and in the process of being fixed.
-- Moreover, if you are using Pandoc up to v2.7, another process may,
-- mistakenly, use the same temporary file at the same time, though this is
-- highly unlikely.
--
-- A citation key may pick out the wrong item if it picks out a different
-- items depending on whether it is interpreted as a Better BibTeX citation
-- key or as an Easy Citekey. Set the 'zotero-citekey-types' metadata field to
-- avoid this (see '[Citation key types](#citation-key-types)' above for
-- details).
--
-- Zotero v5.0.71 and v5.0.72 fail to handle HTTP requests from user agents
-- that do not set the "User Agent" HTTP header. And **pandoc** does not. As a
-- consequence, **pandoc-zotxt.lua** cannot retrieve data from these versions
-- of Zotero unless you tell **pandoc** to set that header.
--
-- SECURITY
-- ========
--
-- If you are using Pandoc up to v2.7 and place the auto-generated
-- bibliography file in a directory that other users have write access to,
-- those users can read and change the content of that file, regardless of
-- whether they have permission to read or write the file itself.
--
-- SEE ALSO
-- ========
--
-- * [Zotero](https://www.zotero.org)
-- * [zotxt](https://github.com/egh/zotxt)
-- * [Better BibTeX for Zotero](https://retorque.re/zotero-better-bibtex/)
--
-- pandoc(1)
--
-- @script pandoc-zotxt.lua
-- @release 1.2.0b
-- @author Odin Kroeger
-- @copyright 2018, 2019, 2020, 2021, 2022 Odin Kroeger
-- @license MIT

-- Table of Contents
--------------------

--- Metadata
-- @section Metadata

--- System
-- @section

--- Types
-- @section

--- Errors
-- @section

--- Variables
-- @section

--- Tables
-- @section

--- Strings
-- @section

--- Prototypes
-- @section

--- Warnings
-- @section

--- File I/O
-- @section

--- Networking
-- @section

--- Markup converters
-- @section

--- CSL items.
--
-- [Appendix IV](https://perma.cc/7LPL-F4XD) of the Citation Style Language
-- (CSL) specification lists all CSL variable names.
--
-- @section

--- Citation keys
-- @section

--- Bibliography files
-- @section

--- Document parsing
-- @section

--- Option parsing
-- @section

--- Zotero connectors
-- @section

--- Main
-- @section

-- Initialisation
-----------------

-- luacheck: allow defined top
-- luacheck: ignore path_prettify

--- Metadata
-- @section

-- luacheck: push ignore DEBUG
--- Run in debugging mode?
local DEBUG = true -- DEBUG or false
-- luacheck: pop

-- Built-in functions.
local assert = assert
local error = error
local getmetatable = getmetatable
local next = next
local pairs = pairs
local pcall = pcall
local rawset = rawset
local require = require
local select = select
local setmetatable = setmetatable
local tonumber = tonumber
local tostring = tostring
local type = type

-- Modules.
local debug = debug
local io = io
local math = math
local os = os
local package = package
local string = string
local table = table
local utf8 = utf8

-- Pandoc.
-- luacheck: push ignore
local pandoc = pandoc
if not pandoc.utils then pandoc.utils = require 'pandoc.utils' end
if not pandoc.List then pandoc.List = require 'List' end

if pandoc.types then
    if PANDOC_VERSION >= {2, 8} and not pandoc.system then
        pandoc.system = require 'pandoc.system'
    end
    if PANDOC_VERSION >= {2, 12} and not pandoc.path then
        pandoc.path = require 'pandoc.path'
    end
end

local PANDOC_STATE = PANDOC_STATE
local PANDOC_SCRIPT_FILE = PANDOC_SCRIPT_FILE
local PANDOC_VERSION = PANDOC_VERSION
-- luacheck: pop

local M = {}
local _ENV = M

-- Shorthands.
local format = string.format
local concat = table.concat
local insert = table.insert
local pack = table.pack
local remove = table.remove
local unpack = table.unpack
local sort = table.sort
local char = utf8.char
local codes = utf8.codes

local stringify = pandoc.utils.stringify

local List = pandoc.List

local Meta = pandoc.Meta
local MetaInlines = pandoc.MetaInlines
local MetaList = pandoc.MetaList
local MetaMap = pandoc.MetaMap
local Pandoc = pandoc.Pandoc
local Plain = pandoc.Plain
local Str = pandoc.Str
local Span = pandoc.Span

local extend = List.extend
local find = List.find
local includes = List.includes
local map = List.map

--------
-- Types
--
-- @section

do
    local abbrs = {
        ['%*'] = 'boolean|function|number|string|table|thread|userdata',
        ['%?(.*)'] = '%1|nil'
    }

    local msg = 'expected %s, got %s.'

    --- Check whether a value is of a type.
    --
    -- <h3>Type declaration grammar:</h3>
    --
    -- Declare one or more Lua type names separated by '|' to require that
    -- the given value is of one of the given types (e.g., 'string|table'
    -- requires the value to be a string or a table). '*' is short for the
    -- list of all types but `nil`. '?T' is short for 'T|nil' (e.g.,
    -- '?table' is short for 'table|nil').
    --
    -- [Extended Backus-Naur Form](https://en.wikipedia.org/wiki/EBNF):
    --
    -- > Type = 'boolean' | 'function' | 'nil'    | 'number'   |
    -- >        'string'  | 'table'    | 'thread' | 'userdata'
    -- >
    -- > Type list = [ '?' ], type, { '|', type }
    -- >
    -- > Wildcard = [ '?' ], '*'
    -- >
    -- > Type declaration = type list | wildcard
    --
    -- <h3>Complex types:</h3>
    --
    -- You can check types of table or userdata fields by
    -- declarding a table that maps indices to declarations.
    --
    --    > type_check({1, '2'}, {'number', 'number'})
    --    nil    index 2: expected number, got string.
    --    > type_check({foo = 'bar'}, {foo = '?table'})
    --    nil    index foo: expected table or nil, got string.
    --    > type_check('foo', {foo = '?table'})
    --    nil    expected table or userdata, got string.
    --
    -- @caveats Wrong type names (e.g., 'int') do *not* throw an error.
    --
    -- @param val A value.
    -- @tparam string|table decl A type declaration.
    -- @treturn[1] bool `true` if the value matches the declaration.
    -- @treturn[2] nil `nil` otherwise.
    -- @treturn[2] string An error message.
    function type_match (val, decl, _seen)
        -- luacheck: ignore t
        local t = type(decl)
        if t == 'string' then
            local t = type(val)
            for p, r in pairs(abbrs) do decl = decl:gsub(p, r) end
            for e in decl:gmatch '[^|]+' do if t == e then return true end end
            return nil, msg:format(decl:gsub('|', ' or '), t)
        elseif t == 'table' then
            local ok, err = type_match(val, 'table|userdata')
            if not ok then return nil, err end
            if not _seen then _seen = {} end
            assert(not _seen[val], 'cycle in data tree.')
            _seen[val] = true
            for k, t in pairs(decl) do
                ok, err = type_match(val[k], t, _seen)
                if not ok then return nil, format('index %s: %s', k, err) end
            end
            return true
        end
        error(msg:format('string or table', t))
    end
end

--- Type-check function arguments in debugging mode.
--
-- <h3>Type declaration grammar:</h3>
--
-- The type declaration syntax is that of @{type_match}, save for
-- that you can use '...' to declare that the remaining arguments
-- are of the same type as the previous one.
--
-- @tip Obscure Lua errors may indicate that forgot the quotes around '...'.
--
-- @caveats
--
-- * Wrong type names (e.g., 'int') do *not* throw an error.
-- * Sometimes the strack trace is wrong.
-- * Returns a pass-through function unless `DEBUG` is true.
--
-- @tparam string|table ... Type declarations.
-- @treturn func A function that adds type checks to a function.
--
-- @usage
-- store = type_check('?*', 'table', '?number', '...')(
--     function (val, tab, ...)
--          local indices = table.pack(...)
--          for i = 1, n do tab[indices[i]] = val end
--     end
-- )
--
-- @function type_check
function type_check (...)
    local decls = pack(...)
    return function (func)
        return function (...)
            -- luacheck: ignore type
            local args = pack(...)
            local decl, prev
            local n = math.max(decls.n, args.n)
            for i = 1, n do
                if     decls[i] == '...' then prev = true
                elseif decls[i]          then prev = false
                                              decl = decls[i]
                elseif not prev          then break
                end
                if args[i] == nil and prev and i >= decls.n then break end
                local ok, err = type_match(args[i], decl)
                if not ok then error(format('argument %d: %s', i, err), 2) end
            end
            return func(...)
        end
    end
end

if not DEBUG then
    function type_check ()
        return function (...) return ... end
    end
end


---------
-- System
--
-- @section

--- The path segment separator used by the operating system.
PATH_SEP = package.config:sub(1, 1)

--- The end of line sequence typically used on the given operating system.
EOL = '\n'
if PATH_SEP == '\\' then EOL = '\r\n' end


-----------
-- File I/O
--
-- @section

do
    -- Patterns that normalise directory paths.
    -- Order is significant.
    local patterns = {
        -- Replace '/./' with '/'.
        {PATH_SEP .. '%.' .. PATH_SEP, PATH_SEP},
        -- Replace a sequence of '/'s with a single '/'.
        {PATH_SEP .. '+', PATH_SEP},
        -- Remove trailing '/'s, but not for the root node.
        {'(.)' .. PATH_SEP .. '$', '%1'},
        -- Remove './' at the beginning of a path.
        {'^%.' .. PATH_SEP, ''}
    }

    --- Normalise a path.
    --
    -- @string path A path.
    -- @treturn string A normalised path.
    --
    -- @function path_normalise
    path_normalise = type_check('string')(
        function (path)
            assert(path ~= '', 'path is the empty string.')
            for i = 1, #patterns do path = path:gsub(unpack(patterns[i])) end
            return path
        end
    )
end

do
    -- Pattern to split a path into a directory and a filename part.
    local pattern = '(.-' .. PATH_SEP .. '?)([^' .. PATH_SEP .. ']-)$'

    --- Split a path into a directory and a filename.
    --
    -- @string path A path.
    -- @treturn string The directory the file is in.
    -- @treturn string The file's name.
    --
    -- @function path_split
    path_split = type_check('string')(
        function (path)
            assert(path ~= '', 'path is the empty string.')
            local dir, fname = path:match(pattern)
            if     dir == ''   then dir = '.'
            elseif fname == '' then fname = '.'
            end
            return path_normalise(dir), fname
        end
    )
end

--- Join multiple path segments.
--
-- @caveats Accepts empty strings as arguments.
--
-- @string ... Path segments.
-- @treturn string A path.
--
-- @function path_join
path_join = type_check('string', '...')(
    function (...)
        return path_normalise(concat({...}, PATH_SEP))
    end
)


-----------
-- Metadata
--
-- @section

--- The name of this script.
NAME = 'pandoc-zotxt.lua'

--- The version of this script.
VERSION = '1.2.0b'

do
    local script_dir, script_name = path_split(PANDOC_SCRIPT_FILE)
    local repo = NAME .. '-' .. VERSION
    local sub_dir = path_join('share', 'lua', '5.4', '?.lua')
    package.path = concat({package.path,
        path_join(script_dir, sub_dir),
        path_join(script_dir, repo, sub_dir)
    }, ';')

    NAME = script_name
end

local json = require 'lunajson'
local text = require 'text'


---------
-- Errors
--
-- @section

--- Create an assertion function.
--
-- See <http://lua-users.org/wiki/FinalizedExceptions>.
--
-- @func fin A finaliser.
-- @func msgh A message handler.
-- @treturn func An assertion functin.
--
-- @function asserter
-- @fixme The documentation is rather cryptic.
-- @fixme Not unit-tested.
asserter = type_check('?function', '?function')(
    function (fin, msgh)
        return function (cond, ...)
            if cond then return cond, ... end
            if fin then fin(...) end
            local err
            if msgh then err = msgh(...)
                    else err = ...
            end
            error(err, 0)
        end
    end
)

--- Create a function that runs in protected mode.
--
-- If an error occurs while running the function,
-- it returns `nil` and an error message.
--
-- See <http://lua-users.org/wiki/FinalizedExceptions>.
--
-- @func func A function.
-- @treturn func A function that runs in protected mode.
--
-- @function protect
-- @fixme Not unit-tested.
protect = type_check('function')(
    function (func)
        return function (...)
            local results = pack(pcall(func, ...))
            if not results[1] then return nil, unpack(results, 2) end
            return unpack(results, 2)
        end
    end
)

-- @fixme
fatalise = type_check('function')(
    function (func)
        return function (...)
            local results = pack(func(...))
            if not results[1] then error(results[2], 0) end
            return unpack(results)
        end
    end
)


------------
-- Variables
--
-- @section

do
    -- Turn @{debug.getlocal} and @{debug.getupvalue} into iterators.
    --
    -- @func func @{debug.getlocal} or @{debug.getupvalue}.
    -- @treturn func A function that returns an iterator.
    local function iterator (func)
        return function (arg)
            local i = 0
            return function ()
                i = i + 1
                return func(arg, i)
            end
        end
    end

    -- Iterate over the upvalues of a function.
    --
    -- @userdata func A @{debug} function value.
    -- @treturn func A stateful iterator.
    local upvalues = iterator(debug.getupvalue)

    -- Iterate over the local variables of a function.
    --
    -- @number level A stack level.
    -- @treturn func A stateful iterator.
    local locals = iterator(debug.getlocal)

    --- Get a copy of the variables of a function.
    --
    -- @caveats
    --
    -- If a global variable is shadowed by a variable that is neither one of
    -- the function's local variables nor one of its upvalues, then the value
    -- from `_ENV` is returned, *not* the value of the shadowing variable.
    --
    -- @int[opt=2] level A stack level, where
    --
    --  * 1 = `vars_get`,
    --  * 2 = the function calling `vars_get`,
    --  * ⋮
    --  * *n* = the function calling the function at level *n* – 1.
    --
    -- @treturn table A mapping of variable names to values.
    --
    -- @usage
    -- > function bar ()
    -- >     print(vars_get(3).foo)
    -- > end
    -- > function foo ()
    -- >     foo = 'foo'
    -- >     bar()
    -- > end
    -- > foo()
    -- foo
    --
    -- @function vars_get
    vars_get = type_check('?number')(
        function (level)
            if not level then level = 2 end
            assert(level > 0, 'level is not a positive number.')
            local info = debug.getinfo(level, 'f')
            assert(info, 'stack is not that high.')
            local vars = copy(_ENV)
            local iters = {upvalues(info.func), locals(level + 1)}
            for i = 1, #iters do
                for k, v in iters[i] do vars[k] = copy(v) end
            end
            return vars
        end
    )
end


---------
-- Tables
--
-- @section

--- A set representation.
--
-- Sets are represented as tables, so that a value `v` is a member of
-- a set `S` if and only if `S[v]` is truthy. See *Progamming in Lua*
-- ([chap. 11.5](https://www.lua.org/pil/11.5.html)) for details.
--
-- @caveats This table exists in documentation only.
-- @table Set

--- Metatable to make index lookups case-insensitive.
--
-- @usage
--
-- > tab = setmetatable({}, ignore_case)
-- > tab.FOO = 'bar'
-- > tab.foo
-- bar
ignore_case = {}

--- Look up an item.
--
-- @tab tab A table.
-- @param key A key.
-- @return The item.
function ignore_case.__index (tab, key)
    if type(key) == 'string' and key:match '%u' then
        return tab[key:lower()]
    end
end

--- Store a new item.
--
-- @tab tab A table.
-- @param key A key.
-- @param val A value.
function ignore_case.__newindex (tab, key, val)
    if type(key) == 'string' then key = key:lower() end
    rawset(tab, key, val)
end

--- Metatable to sort key-value pairs automatically.
--
-- @usage
-- > tab = setmetatable({c = 3, b = 2, a = 1}, sort_pairs)
-- > for k, v in pairs(tab) do
-- >     print(k, v)
-- > end
-- a    1
-- b    2
-- c    3
sort_pairs = {}

--- Iterate over the key-value pairs of a table in a given order.
--
-- What order pairs are iterated over is defined by the `sort` metamethod.
-- Defaults to lexical order if `sort` is unset. See @{sorted} for details.
--
-- @tab tab A table.
-- @treturn func A *stateful* iterator.
--
-- @usage
-- > sort = order{'c', 'b', 'a'}
-- > mt = update({sort = sort}, sort_pairs)
-- > tab = setmetatable({a = 1, b = 2, c = 3}, mt)
-- > for k, v in pairs(tab) do
-- >     print(k, v)
-- > end
-- c    3
-- b    2
-- a    1
function sort_pairs.__pairs (tab)
    local mt = getmetatable(tab)
    return sorted(tab, mt.sort, true)
end

-- Make a deep copy of a value.
--
-- @caveats Bypasses metamethods.
--
-- @param val A value.
-- @return A deep copy.
--
-- @usage
-- > foo = {1, 2, 3}
-- > bar = {foo, 4}
-- > baz = copy(bar)
-- > foo[#foo + 1] = 4
-- > table.unpack(baz, 1)
-- 1    2    3
--
-- @function copy
copy = type_check('?*', '?table')(
    function (val, _seen)
        -- Borrows from:
        -- * <https://gist.github.com/tylerneylon/81333721109155b2d244>
        -- * <http://lua-users.org/wiki/CopyTable>
        if type(val) ~= 'table' then return val end
        if     not _seen  then _seen = {}
        elseif _seen[val] then return _seen[val]
        end
        local cp = {}
        local mt = getmetatable(val)
        if type(mt) == 'table' then setmetatable(cp, mt) end
        _seen[val] = cp
        for k, v in next, val do
            rawset(cp, copy(k, _seen), copy(v, _seen))
        end
        return cp
    end
)

--- Get the indices and number of items in a table.
--
-- @tab tab A table.
-- @treturn tab The indices.
-- @treturn int The number of items.
--
-- @function keys
keys = type_check('table')(
    function (tab)
        local ks = {}
        local n = 0
        for k in pairs(tab) do
            n = n + 1
            ks[n] = k
        end
        return ks, n
    end
)

--- Define a sorting function from an ordered list of values.
--
-- @tab values Values.
-- @treturn func A sorting function.
--
-- @usage
-- > tab = {a = 3, b = 4, c = 2, d = 1}
-- > for k, v in sorted(tab, order{'d', 'c'}) do
-- >     print(k, v)
-- > end
-- d    1
-- c    2
-- a    3
-- b    4
--
-- @function order
order = type_check('table')(
    function (vals)
        local order = {}
        for i = 1, #vals do order[vals[i]] = i end
        return function (a, b)
            local i, j = order[a], order[b]
            if i and j then return i < j end
            if i then return true end
            if j then return false end
            return a < b
        end
    end
)

--- Iterate over the key-value pairs of a table in a given order.
--
-- @tab tab A table.
-- @func[opt] func A sorting function.
--  If no function is given, sorts lexically.
-- @bool[opt=false] raw Bypass `__pairs` metamethod?
-- @treturn func A *stateful* iterator.
--
-- @usage
-- > for k, v in sorted{c = 3, b = 2, a = 1} do
-- >     print(k, v)
-- > end
-- a    1
-- b    2
-- c    3
--
-- @function sorted
-- @fixme `raw` is not unit-tested.
sorted = type_check('table', '?function', '?boolean')(
    function (tab, func, raw)
        local ks
        if raw then ks = pack(tabulate(next, tab))
               else ks = keys(tab)
        end
        sort(ks, func)
        local i = 0
        return function ()
            i = i + 1
            local k = ks[i]
            if k == nil then return end
            return k, tab[k]
        end, tab
    end
)

--- Tabulate the values an iterator returns.
--
-- The iterator must accept, if not honour, the same arguments as @{next}.
--
-- @func iter An iterator.
-- @param[opt] tab A table to iterate over.
-- @param[opt] key The index to start iterating at.
-- @return The values returned by the iterator.
--
-- @usage
-- > str = 'key: value'
-- > k, v = tabulate(split(str, '%s*:%s*', 2))
-- > print(k, v)
-- key    value
--
-- @function tabulate
-- @fixme Stateless iterators are not unit-tested.
tabulate = type_check('function')(
    function (iter, tab, key)
        local vals = Values:clone()
        for v in iter, tab, key do vals:add(v) end
        return unpack(vals)
    end
)

--- Merge tables.
--
-- @caveats The table is updated *in-place*.
--
-- @tab tab A table.
-- @tparam tab|userdata ... Mappings to merge into the table.
-- @treturn tab The table.
--
-- @function update
update = type_check('table', '?table|userdata', '...')(
    function (tab, ...)
        local maps = pack(...)
        for i = 1, maps.n do
            if maps[i] then
                for k, v in pairs(maps[i]) do tab[k] = v end
            end
        end
        return tab
    end
)

--- Walk a tree and apply a function to every node.
--
-- Nodes are only changed if the function returns a value other than `nil`.
--
-- @param val A value.
-- @func func A function.
-- @return A changed value.
--
-- @function walk
walk = type_check('*', 'function', '?table')(
    function (val, func, _seen)
        if type(val) ~= 'table' then
            local ret = func(val)
            if ret == nil then return val end
            return ret
        end
        if     not _seen  then _seen = {}
        elseif _seen[val] then return _seen[val]
        end
        local ret = {}
        local mt = getmetatable(val)
        if type(mt) == 'table' then setmetatable(ret, mt) end
        _seen[val] = ret
        for k, v in pairs(val) do
            if type(v) == 'table' then v = walk(v, func, _seen) end
            local new = func(v)
            if new == nil then ret[k] = v
                          else ret[k] = new
            end
        end
        return ret
    end
)


----------
-- Strings
--
-- @section

--- Iterate over substrings of a string.
--
-- @caveats Neither supports multi-byte characters nor frontier patterns.
--
-- @string str A string.
-- @string pattern Where to split the string.
-- @int[opt] max Split the string into at most that many substrings.
-- @string[opt] include Include separators in substrings?
--
--  * 'l' includes them on the left,
--  * 'r' on the right.
--
--  By default, separators are *not* included.
-- @treturn func A *stateful* iterator.
--
-- @usage
-- > for s in split('CamelCase', '%u', nil, 'l') do
-- >     print(string.format("%s", s))
-- > end
-- ""
-- "Camel"
-- "Case"
--
-- @function split
split = type_check('string', 'string', '?number', '?string')(
    function (str, pattern, max, include)
        assert(not pattern:match '%f[%%]%%f', 'split does not support %f.')
        assert(not include or include:match '^[lr]$', 'expecting "l" or "r".')
        local pos = 1
        local n = 0
        local i, j
        return function ()
            local sep, last
            if not pos then return end
            if include == 'l' and i then sep = str:sub(i, j) end
            i = nil
            j = nil
            n = n + 1
            if n == max then
                last = -1
            else
                i, j = str:find(pattern, pos)
                if     not i          then last = -1
                elseif include == 'r' then last = j
                                      else last = i - 1
                end
            end
            local sub = str:sub(pos, last)
            if sep then sub = sep .. sub end
            if j then pos = j + 1
                 else pos = nil
            end
            return sub
        end
    end
)

--- Remove leading and trailing whitespace.
--
-- @string str A string.
-- @treturn string A trimmed string.
--
-- @function trim
trim = type_check('string')(
    function (str)
        return str:gsub('^%s+', ''):gsub('%s*$', ''), nil
    end
)

do
    -- Lookup a path in a namespace.
    --
    -- @tab vars A mapping of variable names to values.
    -- @string path A path. Seperate segments by dots.
    -- @return[1] A non-`nil` value.
    -- @treturn[2] nil `nil` if an error occurs.
    -- @treturn[2] string An error message.
    local function lookup (vars, path)
        if path == '' then return nil, 'name is the empty string.' end
        local segs = pack(tabulate(split(path, '%.')))
        local v = vars
        for i = 1, segs.n do
            local n = segs[i]
            if i < segs.n then
                local ok, err = type_match(v, {[n] = 'table'})
                if not ok then return nil, err end
            end
            v = v[n]
        end
        if v == nil then return v, path .. ' is undefined.' end
        return v
    end

    -- Expand a variable from a variable expression.
    --
    -- See @{vars_sub} for the expression syntax.
    --
    -- @tparam Set seen The variables encounterd so far.
    -- @tab vars A mapping of variable names to values.
    -- @string exp A variable expression.
    -- @treturn string The value of the expression.
    -- @raise See @{vars_sub}.
    --
    -- @todo Allow pipes of arbitrary lengths.
    local function expand (seen, vars, exp)
        -- luacheck: ignore assert
        local function msgh (err) return format('$%s: %s', exp, err) end
        local assert = asserter(nil, msgh)
        local pipe = pack(tabulate(split(exp:sub(2, -2), '|')))
        local path = pipe[1]
        assert(not seen[path], 'cycle in lookup.')
        seen[path] = true
        local v = assert(lookup(vars, path))
        if type(v) == 'string' then v = assert(vars_sub(v, vars, seen)) end
        for i = 2, #pipe do
            local fn = pipe[i]
            local f = assert(lookup(vars, fn))
            assert(type(f) == 'function', fn .. ': not a function.')
            v = f(v)
        end
        assert(type_match(v, 'string|number'))
        return tostring(v)
    end

    --- Substitute variables in strings.
    --
    -- If a string of characters is placed within braces ('{...}') and the
    -- opening brace ('{') immediately follows a single dollar ('$') sign,
    -- then that string names a variable and the whole expression is
    -- replaced with the value of that variable.
    --
    --    > vars_sub(
    --    >     '${v1} is ${v2}.',
    --    >     {v1 = 'foo', v2 = 'bar'}
    --    > )
    --    foo is bar.
    --
    -- If a braced string is preceded by two or more dollar signs, it is *not*
    -- a variable name and the expression, therefore, *not* replaced. Moreover,
    -- any series of *n* dollar signs is replaced with *n* – 1 dollar signs.
    --
    --    > vars_sub(
    --    >     '$${var} costs $$1.',
    --    >     {var = 'foo'}
    --    > )
    --    ${var} costs $1.
    --
    -- You can lookup values in tables by joining the name of the variable
    -- and that of the table index with a dot ('.'). Neither variable nor
    -- function names can contain dots.
    --
    --    > vars_sub(
    --    >     '${foo.bar} is baz.', {
    --    >         foo = { bar = 'baz' }
    --    >     }
    --    > )
    --    baz is baz.
    --
    -- If a name is followed by a pipe symbol ('|'), then the string between
    -- that pipe symbol and the next pipe symbol/the closing brace ('}') names
    -- a function; the value is then passed to that function, and the whole
    -- expression replaced with the first value that the function returns.
    -- Neither variable nor function names may contain pipe symbols.
    --
    --    > vars_sub(
    --    >     '${var|barify} is bar!', {
    --    >         var = 'foo',
    --    >         barify = function (s)
    --    >             return s:gsub('foo', 'bar')
    --    >         end
    --    >     }
    --    > )
    --    bar is bar!
    --
    -- Variables are substituted recursively.
    --
    --    > vars_sub(
    --    >     '${foo|barify} is bar.', {
    --    >         foo = '${bar}',
    --    >         bar = 'baz'
    --    >         barify = function (s) return s:gsub('baz', 'bar') end
    --    >     }
    --    > )
    --    bar is bar.
    --
    -- @string str A string.
    -- @tparam func|tab mapping A mapping of variable names to values.
    -- @treturn[1] string A transformed string.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    --
    -- @function vars_sub
    -- @fixme Functions are not unit-tested.
    -- @fixme Chained function calls in pipes are not unit-tested.
    vars_sub = type_check('string', 'function|table', '?table')(protect(
        function (str, mapping, _seen)
            if not _seen then _seen = {} end
            local repl
            local t = type(mapping)
            if t == 'function' then
                repl = mapping
            elseif t == 'table' then
                repl = function (...) return expand(_seen, mapping, ...) end
            else
                error 'FIXME'
            end
            return str:gsub('%f[%$]%$(%b{})', repl):gsub('%$(%$*)', '%1'), nil
        end
    ))
end

do
    -- luacheck: ignore assert

    -- Enable variable substitution in error messages.
    local function msgh (msg) return assert(vars_sub(msg, vars_get(4))) end

    -- Make assertions without stack traces.
    local assert = asserter(nil, msgh)

    -- @fixme
    local function get_env (key)
        local var = key:sub(2, -2)
        assert(var ~= '', '$${}: variable name is the empty string.')
        assert(var:match '^[%a_][%w_]+$', '$${${var}}: invalid variable name.')
        local val = assert(os.getenv(var), '$${${var}}: is undefined.')
        if val == '' then xwarn('$${${var}}: is empty.') end
        return val
    end

    -- @fixme
    function env_sub (str)
        return vars_sub(str, get_env)
    end
end


-------------
-- Prototypes
--
-- @section

--- Base prototype.
--
-- @object Object
Object = {}

--- Delegate to an object.
--
-- Set a table's metatable to a copy of the objects's metatable and the
-- table's `__index` metavalue to the object. If no table is given,
-- create one. If a metatable is given, override the table's new metatable
-- with that table. In other words,
--
--     Object:clone(tab, mt)
--
-- is roughly equivalent to
--
--     do
--         local mt = update({}, getmetatable(Object), {__index = Object}, mt)
--         setmetatable(tab or {}, mt)
--     end
--
-- @caveats The table is changed *in-place*.
--
-- @tab[opt] tab A table.
-- @tab[opt] mt A metatable.
-- @treturn tab The table.
--
-- @usage
-- > Foo = Object:clone({}, {__tostring = function (t) return t.bar end})
-- > Foo.bar = 'baz'
-- > tostring(Foo)
-- baz
-- > bar = Foo()
-- > tostring(bar)
-- baz
-- > bar.bar = 'bar'
-- > tostring(bar)
-- bar
--
-- @function Object:clone
Object.clone = type_check('table', '?table', '?table')(
    function (self, tab, mt)
        mt = update({}, getmetatable(self), {__index = self}, mt)
        return setmetatable(tab or {}, mt)
    end
)

--- Create and initialise a table that delegates to the object.
--
-- `Object:new(...)` is short for `update(Object:clone(), ...)`.
--
-- @tab ... Properties.
-- @treturn Object An object.
--
-- @usage
-- > foo = Object:new{foo = 'foo'}
-- > foo.foo
-- foo
--
-- @function Object:new
Object.new = type_check({clone = 'function'}, '?table', '...')(
    function (proto, ...)
        return update(proto:clone(), ...)
    end
)

--- Metatable for prototypes.
Object.mt = {}
setmetatable(Object, Object.mt)

--- Shorthand for @{Object:new}.
--
-- @tab ... Passed to @{Object:new}.
-- @treturn Object An object.
--
-- @function Object.mt.__call
Object.mt.__call = type_check({new = 'function'})(
    function (self, ...)
        return self:new(...)
    end
)

--- A simple list.
--
-- @tip
--
-- You can sparse-copy a `Values` object by using it as a prototype:
--
--    > foo = Values:new 'foo'
--    > bar = foo()
--    > bar:add 'bar'
--    > #bar
--    2
--    > for i, v in ipairs(bar) do
--    >     print(i, v)
--    > end
--    1    foo
--    2    bar
--
-- @usage
-- > list = Values()
-- > list:add 'a string'
-- > list.n
-- 1
--
-- @object Values
-- @proto @{Object}
Values = Object:clone()

--- Metatable for values.
Values.mt = getmetatable(Values)

--- Get the size of the list.
--
-- @tparam Values obj A list.
-- @treturn number The size of the list.
--
-- @function Values.mt.__len
Values.mt.__len = type_check({n = '?number'})(
    function (obj)
        return obj.n or 0
    end
)

--- Add items to the list.
--
-- @tparam Values obj A list.
-- @param key An index.
-- @param val A value.
--
-- @side Sets @{Values.n} to the number of items in the list.
--
-- @function Values.mt.__newindex
Values.mt.__newindex = type_check({n = '?number'})(
    function (obj, key, val)
        if type(key) == 'number' and key > obj.n then obj.n = key end
        rawset(obj, key, val)
    end
)

--- Iterate over list items.
--
-- @tparam Values obj A list.
-- @treturn function A stateless iterator.
--
-- @function Values.mt.__pairs
Values.mt.__pairs = type_check({n = '?number'})(
    function (obj)
        return function (tab, i)
            if not i then i = 1
                     else i = i + 1
            end
            if not tab.n or i > tab.n then return end
            return i, tab[i]
        end, obj
    end
)

--- The number of items in the list.
Values.n = 0

--- Create a new list.
--
--    list = Values:new(...)
--
-- is short for:
--
--    list = Values:new()
--    list:add(...)
--
-- @tip
--
-- You can convert an 'ordinary' list to a `Values` object by:
--
--    tab.n = #tab
--    Values:clone(tab)
--
-- @param ... Items.
-- @treturn Values A new list.
--
-- @function Values:new
Values.new = type_check({add = 'function'})(
    function (proto, ...)
        local obj = Object.new(proto)
        if select('#', ...) > 0 then obj:add(...) end
        return obj
    end
)

--- Add items to the list.
--
-- @side Sets @{Values.n} to the number of items in the list.
--
-- @param ... Items.
--
-- @function Values:add
Values.add = type_check({n = 'number'})(
    function (self, ...)
        local items = pack(...)
        local n = self.n
        for i = 1, items.n do rawset(self, n + i, items[i]) end
        self.n = n + items.n
    end
)

--- Add getters to a table.
--
-- <h3>Getter protocol:</h3>
--
-- If an index is not present in a the table, look for a function of the same
-- name in the table's `getters` metavalue, which must be a mapping of indices
-- to functions. If `getters` contains a function of that name, then that
-- function is called with the table as its only argument and whatever it
-- returns is returned as the value of the given index. If `getters` does
-- not contain a function of that name, the name is looked up using the
-- table's *old* `__index` metavalue.
--
-- @caveats
--
-- * Tables are modified *in-place*.
-- * Getters are *not* inherited.
--
-- @tab tab A table.
-- @treturn tab The table.
--
-- @usage
-- > -- Enable getters for an object:
-- > Foo = getterify(Object:clone())
-- > Foo.foo = 'bar'
-- > mt = getmetatable(Foo)
-- > mt.getters = {}
-- > function mt.getters.bar (obj) return obj.foo end
-- > Foo.bar
-- bar
-- > -- The getter is reached via the prototype chain,
-- > -- so it sees Foo.foo, not bar.foo:
-- > baz = Foo()
-- > baz.foo = 'bam!'
-- > baz.bar
-- bar
-- > -- But you can make getters quasi-inheritable:
-- > Foo.clone = function (...) return getterify(Object.clone(...)) end
-- > baz = Foo()
-- > baz.foo = 'bam!'
-- > baz.bar
-- bam!
--
-- @function getterify
-- @fixme Not unit-tested.
getterify = type_check('table')(
    function (tab)
        local mt = update({}, getmetatable(tab))
        local index = mt.__index
        mt.__index = type_check('table')(
            -- luacheck: ignore tab
            function (tab, key)
                local getters = getmetatable(tab).getters
                if getters then
                    local get = getters[key]
                    if get then return get(tab) end
                end
                if index then
                    local t = type(index)
                    if t == 'table'    then return index[key]      end
                    if t == 'function' then return index(tab, key) end
                    error(format('__index points to %s.', t), 2)
                end
            end
        )
        return setmetatable(tab, mt)
    end
)

-----------
-- Warnings
-- @section

do
    -- Priority levels for messages.
    local levels = {'error', 'warning', 'info'}

    -- What level if verbosity is desired.
    local verbosity = PANDOC_STATE.verbosity:lower()

    --- Compare verbosity levels.
    --
    -- @string a A verbosity level.
    -- @string b Another verbosity level.
    -- @treturn bool Whether level A is smaller than level B.
    local verb_lt = order(levels)

    --- Print a message to STDERR.
    --
    -- <h3>Printout:</h3>
    --
    -- Prefixed with `NAME .. ': '` and terminated with @{EOL}.
    -- Non-string values are coerced to strings.
    --
    -- <h3>Message priority:</h3>
    --
    -- Messages are only printed if their priority is greater or equal to
    -- `PANDOC_STATE.verbostiy`.
    --
    -- <h3>Variable substitution:</h3>
    --
    -- If string values contain variable names, they are replaced with the
    -- values of the local variables or the upvalues of the calling function
    -- or, if there are no local variables or upvalues of the given names,
    -- the values of the global variables of the module. See @{vars_sub} for
    -- the syntax and @{vars_get} for limitations.
    --
    -- <h3>Options:</h3>
    --
    -- String values starting with an '@' are interpreted as options:
    --
    -- * '@error', '@warning', '@info': Set the message's priority.
    --   (*default* 'warning')
    -- * '@noopts': Turn option processing off. (*default* on)
    -- * '@novars': Turn variable substitution off. (*default* on)
    -- * '@plain': Turn variable substitution *and* option processing off.
    -- * '@vars': Turn variable substitution on.
    --
    -- Options are case-sensitive. Unknown options are ignored.
    --
    -- @param ... Messages. At least one must be given.
    --
    -- @function xwarn
    xwarn = type_check('*')(
        function (...)
            local priority = 'warning'
            local opts = {opts = true, vars = true}
            local function opts_set (msg)
                if not opts.opts or msg:sub(1, 1) ~= '@' then return end
                local opt = msg:sub(2)
                if     includes(levels, opt) then priority = opt
                elseif opt == 'plain'        then opts.vars = false
                                                  opts.opts = false
                elseif opt:match '^no'       then opts[opt:sub(3)] = false
                                             else opts[opt] = true
                end
                return true
            end
            local vars
            local msgs = pack(...)
            local nopt = 0
            for i = 1, msgs.n do
                local msg = msgs[i]
                if type(msg) ~= 'string' then
                    msgs[i] = tostring(msg)
                elseif opts_set(msg) then
                    msgs[i] = ''
                    nopt = nopt + 1
                elseif opts.vars then
                    if not vars then vars = vars_get(3) end
                    msgs[i] = assert(vars_sub(msg, vars))
                end
            end
            if verb_lt(verbosity, priority) or nopt == msgs.n then return end
            io.stderr:write(concat{NAME, ': ', concat(msgs), EOL})
        end
    )
end


-----------
-- File I/O
--
-- @section

--- Check whether a path is absolute.
--
-- @caveats Accepts the empty string as path since Pandoc v2.12.
--
-- @string path A path.
-- @treturn bool `true` if the path is absolute, `false` otherwise.
--
-- @function path_is_abs
if not pandoc.types or PANDOC_VERSION < {2, 12} then
    path_is_abs = type_check('string')(
        function (path)
            assert(path ~= '', 'path is the empty string.')
            if PATH_SEP == '\\' and path:match '^.:\\' then return true end
            return path:match('^' .. PATH_SEP) ~= nil
        end
    )
else
    path_is_abs = pandoc.path.is_absolute
end

--- Make a path absolute.
--
-- @require Pandoc v2.8
--
-- @string path An absolute or relative path.
-- @treturn string An absolute path.
-- @function path_make_abs
if pandoc.types and PANDOC_VERSION >= {2, 8} then
    path_make_abs = type_check('string')(
        function (path)
            assert(path ~= '', 'path is the empty string.')
            if path_is_abs(path) then return path end
            local cwd = pandoc.system.get_working_directory()
            assert(cwd ~= '', 'current working directory is the empty string.')
            return path_join(cwd, path)
        end
    )
end

do
    local get_working_directory
    if pandoc.types and PANDOC_VERSION >= {2, 8} then
        get_working_directory = pandoc.system.get_working_directory
    end

    local home_dir
    do
        if PATH_SEP == '/' then
            local env_home = os.getenv('HOME')
            if env_home and env_home ~= '' and path_is_abs(env_home) then
                home_dir = path_normalise(env_home)
            end
        end
    end

    --- Prettify paths.
    --
    -- Removes the working directory from the beginning of the path. On
    -- POSIX systems, also replaces the user's home directory with '~'.
    --
    -- @string path A path.
    -- @treturn string A prettier path.
    -- @require The working directory is *not* removed from the beginning
    --  of a path under Pandoc < v2.12.
    --
    -- @function path_prettify
    path_prettify = type_check('string')(
        function (path)
            assert(path ~= '', 'path is the empty string.')
            path = path_normalise(path)
            if get_working_directory then
                local cwd = get_working_directory()
                local pos = #cwd + 1
                if path:sub(1, pos) == cwd .. PATH_SEP then
                    return path:sub(pos + 1)
                end
            end
            if home_dir then
                local pos = #home_dir + 1
                if path:sub(1, pos) == home_dir .. PATH_SEP then
                    return '~' .. path:sub(pos)
                end
            end
            return path
        end
    )
end

do
    local get_working_directory
    if pandoc.types and PANDOC_VERSION >= {2, 8} then
        get_working_directory = pandoc.system.get_working_directory
    end

    --- Guess the project directory.
    --
    -- The project directory is the directory of the first input file *not*
    -- *not* named '-' (i.e., of the first actual input file). If there is no
    -- such file, the project directory is the current working directory.
    --
    -- @require The working directory is represented by '.'
    --  under Pandoc < v2.8.
    --
    -- @treturn string A directory.
    function project_dir ()
        local input_files = PANDOC_STATE.input_files
        for i = 1, #input_files do
            local fname = input_files[i]
            if fname ~= '-' then return path_split(fname), nil end
        end
        if get_working_directory then return get_working_directory() end
        return '.'
    end
end

--- Check whether a file exists.
--
-- @caveats
--
-- Another process may create a file of the given name between the time
-- `file_exists` tries to access that file and the time it returns.
--
-- @string fname A filename.
-- @treturn[1] boolean `true` if the file exists.
-- @treturn[2] nil `nil` if the file does not exist.
-- @treturn[2] string An error message.
-- @treturn[2] int The error number 2.
-- @raise An error if the file cannot be closed again.
--
-- @function file_exists
file_exists = type_check('string')(
    function (fname)
        assert(fname ~= '', 'filename is the empty string.')
        local file, err, errno = io.open(fname, 'r')
        if not file then return nil, err, errno end
        assert(file:close())
        return true
    end
)

do
    local resource_path = PANDOC_STATE.resource_path

    --- Locate a file in Pandoc's resource path.
    --
    -- @caveats Absolute filenames are returned as they are.
    --
    -- @string fname A filename.
    -- @treturn[1] string A filename in Pandoc's resource path.
    -- @treturn[2] nil `nil` if the file could not be found.
    -- @treturn[2] string An error message.
    --
    -- @function file_locate
    file_locate = type_check('string')(
        function (fname)
            assert(fname ~= '', 'filename is the empty string.')
            if not resource_path or path_is_abs(fname) then return fname end
            for i = 1, #resource_path do
                local dir = resource_path[i]
                if dir == '' then
                    local err = 'resource path %d is the empty string.'
                    return nil, format(err, i)
                end
                local path = path_join(dir, fname)
                if file_exists(path) then return path end
            end
            return nil, fname .. ': not found in resource path.'
        end
    )
end

--- Read a file.
--
-- @string fname A filename.
-- @treturn[1] string The contents of the file.
-- @treturn[2] nil `nil` if an error occurred.
-- @treturn[2] string An error message.
-- @treturn[2] int An error number.
--
-- @function file_read
file_read = type_check('string')(
    function (fname)
        assert(fname ~= '', 'filename is the empty string.')
        local str, err, errno, file, ok
        file, err, errno = io.open(fname, 'r')
        if not file then return nil, err, errno end
        str, err, errno = file:read('a')
        if not str then return nil, err, errno end
        ok, err, errno = file:close()
        if not ok then return nil, err, errno end
        return str
    end
)

do
    -- Write data to a file (worker).
    --
    -- @param file The name or handle of a file to write data to.
    -- @string ... The data.
    -- @treturn[1] bool `true` if the data was written out sucessfully.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    -- @treturn[2] int An error number.
    local function write (fname, ...)
        local file, ok, err, errno
        file, err, errno = io.open(fname, 'w')
        if not file then return nil, err, errno end
        ok, err, errno = file:write(...)
        if not ok then return nil, err, errno end
        ok, err, errno = file:flush()
        if not ok then return nil, err, errno end
        return file:close()
    end

    --- Write data to a file.
    --
    -- If a file of that name exists already, it is overwritten.
    --
    -- @caveats
    --
    -- Data is first written to a temporary file, that file is then renamed
    -- to the given filename. This is safe and secure starting with Pandoc
    -- v2.8. If you are using an older version of Pandoc, the caveats of
    -- @{with_tmp_file} apply.
    --
    -- @side Creates and deletes a temporary file.
    --
    -- @string fname A filename.
    -- @string ... The data.
    -- @treturn[1] bool `true` if the data was written to the given file.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    -- @treturn[2] int An error number.
    -- @raise Under Pandoc < v2.8, an error if no unused temporary filename
    --  could be generated. Otherwise, an error if the temporary directory
    --  could not be created; this error cannot be caught.
    -- @function file_write
    file_write_legacy = type_check('string')(
        function (fname, ...)
            assert(fname ~= '', 'filename is the empty string.')
            local dir = path_split(fname)
            local data = {...}
            return with_tmp_file(function(tf)
                local ok, err, errno
                xwarn 'writing to temporary file ${tf|path_prettify}.'
                ok, err, errno = write(tf, unpack(data))
                if not ok then return nil, err, errno end
                ok, err, errno = os.rename(tf, fname)
                if not ok then return nil, err, errno end
                xwarn 'renamed ${tf|path_prettify} to ${fname|path_prettify}.'
                return true
            end, dir)
        end
    )

    do
        local with_temporary_directory = pandoc.system.with_temporary_directory

        file_write_modern = type_check('string')(
            function (fname, ...)
                assert(fname ~= '', 'filename is the empty string.')
                local dir, base = path_split(path_make_abs(fname))
                local data = {...}
                local tmp_dir
                local ok, err, errno = with_temporary_directory(dir, 'pdz',
                    function (td)
                        tmp_dir = td
                        xwarn 'made temporary directory ${td|path_prettify}.'
                        local tmp_file = path_join(td, base)
                        local ok, err, errno = write(tmp_file, unpack(data))
                        if not ok then return nil, err, errno end
                        return os.rename(tmp_file, fname)
                    end
                )
                if tmp_dir and not file_exists(tmp_dir) then
                    xwarn 'removed ${tmp_dir|path_prettify}.'
                end
                return ok, err, errno
            end
        )
    end

    if not pandoc.types or PANDOC_VERSION < {2, 8}
        then file_write = file_write_legacy
        else file_write = file_write_modern
    end
end

do
    -- List of all alphanumeric characters.
    local alnum = Values()

    do
        -- These are the ASCII/UTF-8 ranges for alphanumeric characters.
        local ranges = {
            {48,  57},  -- 0-9.
            {65,  90},  -- A-Z.
            {97, 122}   -- a-z.
        }

        -- Populate a list of alphanumeric characters.
        for i = 1, #ranges do
            local first, last = unpack(ranges[i])
            for j = first, last do alnum:add(string.char(j)) end
        end
    end

    math.randomseed(os.time())

    --- Generate a name for a temporary file.
    --
    -- @caveats
    --
    -- Another process may create a file of the same name between the time
    -- `tmp_fname` checks whether that name is in use and the time it returns.
    --
    -- @string[opt] dir A directory to prefix the filename with.
    -- @string[opt='pdz-XXXXXX'] templ A template for the filename.
    --  'X's are replaced with random alphanumeric characters.
    -- @treturn[1] string A filename.
    -- @treturn[2] nil `nil` if the generated filename is in use.
    -- @treturn[2] string An error message.
    --
    -- @function tmp_fname
    tmp_fname = type_check('?string', '?string')(
        function (dir, templ)
            assert(dir ~= '', 'directory is the empty string.')
            if not templ then templ = 'pdz-XXXXXX' end
            if dir then templ = path_join(dir, templ) end
            local len = #templ
            for _ = 1, 32 do
                local fname = ''
                for i = 1, len do
                    local c = templ:sub(i, i)
                    if c == 'X' then c = alnum[math.random(1, alnum.n)] end
                    fname = fname .. c
                end
                if not file_exists(fname) then return fname end
            end
            return nil, 'failed to find unused temporary filename.'
        end
    )
end

--- Run a function with a temporary file.
--
-- Generates a temporary filename. Does *not* create that file.
-- If the function raises an error or returns `nil` or `false`,
-- the temporary file is deleted.
--
-- @caveats
--
-- The temporary file may have been created by *another* process. If that
-- file is located within a directory that other users have write access
-- to (e.g., `/tmp`), then this is a security issue.
--
-- @side May print error messages to STDERR.
--
-- @func func Given the name of the temporary file.
--  Must *not* change the working directory.
-- @string[opt] dir A directory to prefix the name
--  of the temporary file with. See @{tmp_fname}.
-- @string[opt] templ A template for the name
--  of the temporary file. See @{tmp_fname}.
-- @return The values returned by the function.
-- @raise An error if no unused temporary filename could be generated.
--
-- @function with_tmp_file
with_tmp_file = type_check('function', '?string', '?string')(
    function (func, dir, templ)
        local tmp_file, err = tmp_fname(dir, templ)
        if not tmp_file then error(err, 0) end
        local results = pack(pcall(func, tmp_file))
        local ok, success = unpack(results, 1, 2)
        if not ok or not success then
            -- luacheck: ignore ok err
            local ok, err, errno = os.remove(tmp_file)
            if     ok         then xwarn 'removed ${tmp_file|path_prettify}.'
            elseif errno ~= 2 then xwarn('@error', '@plain', err)
            end
        end
        return unpack(results, 2)
    end
)


-------------
-- Networking
--
-- @section

--- Retrieve data from a URL via an HTTP GET request.
--
-- @string url A URL.
-- @treturn string The MIME type of the HTTP content, in lower case.
-- @treturn string The HTTP content itself.
-- @raise An error if the host cannot be connected to.
--  This error can only be caught in Pandoc ≥ v2.11.
--
-- @function http_get
http_get = type_check('string')(
    function (url)
        assert(url ~= '', 'URL is the empty string.')
        local mt, con = pandoc.mediabag.fetch(url, '.')
        return mt:lower(), con
    end
)


--------------------
-- Markup converters
--
-- @section

do
    -- Escape bold and italics meta characters.
    --
    -- @string chr The first character of a bold or italics expression.
    -- @string tail The rest of the expression.
    -- @treturn string The escaped expression.
    local function escape_bold_italics (chr, tail)
        return chr:gsub('(.)', '\\%1') .. tail
    end

    -- Escape superscript and subscript meta characters.
    --
    -- @string char The first character of a super- or subscript expression.
    -- @string body The content of the expression.
    -- @string tail The last character of the expression.
    -- @treturn string The escaped expression.
    local function escape_sup_sub (head, body, tail)
        return head:gsub('(.)', '\\%1') .. body .. tail:gsub('(.)', '\\%1')
    end

    -- Escape links and spans.
    --
    -- @string brack The bracketed expression.
    -- @string tail '(' or '{'.
    -- @treturn string The escaped expression.
    local function escape_link_span (brack, tail)
        return '\\[' .. brack:sub(2, -2) .. '\\]' .. tail
    end

    -- Pairs of expressions and replacement functions.
    local patterns = {
        -- Backslashes.
        {'(\\+)', '\\%1'},
        -- Bold and italics.
        -- Escapes liberally, but that's the easiest way to cover edge cases.
        {'(%*+)([^%s%*])', escape_bold_italics},
        {'(_+)([^%s_])', escape_bold_italics},
        -- Superscript and subscript.
        {'(%^+)([^%^%s]*)(%^+)', escape_sup_sub},
        {'(~+)([^~%s]+)(~+)', escape_sup_sub},
        -- Brackets (spans and links).
        {'(%b[])([%({])', escape_link_span}
    }

    local npatterns = #patterns

    --- Escape Markdown syntax.
    --
    -- @caveats
    --
    -- Only escapes [Markdown that Pandoc recognises in bibliographic
    -- data](https://pandoc.org/MANUAL.html#specifying-bibliographic-data).
    --
    -- @string str Non-Markdown text.
    -- @treturn string Text with Markdown syntax escaped.
    --
    -- @usage
    -- > escape_markdown '*text*'
    -- \*text*
    --
    -- @function escape_markdown
    escape_markdown = type_check('string')(
        function (str)
            for i = 1, npatterns do str = str:gsub(unpack(patterns[i])) end
            return str
        end
    )
end

do
    -- Shorthands
    -- luacheck: ignore type
    local type = pandoc.utils.type
    local walk_inline = pandoc.walk_inline
    local write = pandoc.write

    -- luacheck: ignore assert
    -- Don't add a stack trace.
    local assert = asserter()

    -- Filter to escape Markdown in Pandoc string elements.
    local escape_str = {}

    -- Escape Markdown in a string element.
    --
    -- Works like @{escape_markdown} but for Pandoc string elements.
    --
    -- @tparam pandoc.Str str A Pandoc string element.
    -- @treturn pandoc.Str A string with all Markdown syntax escaped.
    function escape_str.Str (str)
        return Str(escape_markdown(str.text))
    end

    -- Filter to convert to Markdown.
    local to_markdown = {}

    -- Make a function that converts an element to Markdown.
    --
    -- @string char A Markdown markup character.
    -- @treturn func A conversion function.
    local function converter (chr)
        return function (elem)
            local str = stringify(walk_inline(elem, to_markdown))
            return Str(chr .. str .. chr)
        end
    end

    -- Convert AST elements into Markdown text.
    to_markdown.Emph = converter '*'
    to_markdown.Strong = converter '**'
    to_markdown.Subscript = converter '~'
    to_markdown.Superscript = converter '^'

    local msg = '"%s" contains forbidden characters.'

    -- Convert HTML span elements to Markdown text.
    --
    -- @tparam pandoc.Span An HTML span element.
    -- @treturn pandoc.Str A Markdown representation.
    function to_markdown.Span (span)
        local str = stringify(pandoc.walk_inline(span, to_markdown))
        local attrs = Values()

        local identifier = span.identifier
        if identifier and identifier ~= '' then
            if identifier:match '%s' then error(msg:format(identifier), 0) end
            attrs:add('#' .. identifier)
        end

        local classes = span.classes
        if classes then
            for i = 1, #classes do
                local class = classes[i]
                if class ~= '' then
                    if class:match '%s' then error(msg:format(class), 0) end
                    attrs:add('.' .. class)
                end
            end
        end

        local attributes = span.attributes
        if attributes then
            for k, v in pairs(attributes) do
                if v ~= '' then
                    if k:match '[%c%s="\'>/]' then error(msg:format(k), 0) end
                    if v:match '["\'=<>`]' then error(msg:format(v), 0) end
                    attrs:add(format('%s="%s"', k, v))
                end
            end
        end

        if attrs.n > 0 then
            str = '[' .. str ..                ']' ..
                  '{' .. concat(attrs, ' ') .. '}'
        end
        return Str(str)
    end

    -- Convert a Pandoc small capitals elements to Markdown text.
    --
    -- @tparam pandoc.SmallCaps A SmallCaps element.
    -- @treturn pandoc.Str A Markdown representation.
    function to_markdown.SmallCaps (sc)
        local span = Span(sc.content)
        insert(span.classes, 'smallcaps')
        return to_markdown.Span(span)
    end

    --- Convert a Pandoc element to Markdown text.
    --
    -- @require
    --
    -- Only recognises [elements Pandoc permits in bibliographic
    -- data](https://pandoc.org/MANUAL.html#specifying-bibliographic-data)
    -- if run with Pandoc < v2.17.
    --
    -- @tparam pandoc.AstElement elem A Pandoc AST element.
    -- @treturn string Markdown text.
    -- @raise An error if the element cannot be converted.
    --
    -- @function markdownify
    -- @todo Unit-test parse errors?
    markdownify_legacy = type_check('table|userdata')(
        function (elem)
            local escaped = elem_walk(elem, escape_str)
            return stringify(elem_walk(escaped, to_markdown))
        end
    )

    markdownify_modern = type_check('table|userdata')(
        function (elem)
            if type(elem) ~= 'Pandoc' then elem = Pandoc{Plain(elem)} end
            return write(elem, 'markdown'):gsub('\r?\n$', ''), nil
        end
    )

    if not pandoc.types or PANDOC_VERSION < {2, 17}
        then markdownify = markdownify_legacy
        else markdownify = markdownify_modern
    end
end

do
    local rep = string.rep

    --- Create a number of spaces.
    --
    -- @int n The number of spaces.
    -- @treturn string `n` spaces.
    local function spaces (n)
        return rep(' ', n)
    end

    --- Convert a string to a YAML scalar.
    --
    -- @caveats
    --
    -- * Strings *must* be encoded in UTF-8.
    -- * Does *not* escape *all* non-printable characters.
    --
    -- @string str A string.
    -- @bool[opt] unquoted Quote strings only when needed?
    -- @treturn string A YAML scalar.
    local function scalarify (str, unquoted)
        -- Simple strings may need no special treatment.
        if
            unquoted                and
            not str:match '^%d+$'   and
            str:match '^[%w%s%-]+$'
        then return str end

        -- Replace line breaks with the OS' EOL sequence.
        str = str:gsub('\r?\n', EOL)

        -- Escape special and control characters.
        local chars = Values()
        for _, c in codes(str, true) do
            if
                c == 0x22 or -- '"'
                c == 0x5c    -- '\'
            then chars:add('\\' .. char(c))
            elseif
                c == 0x09 or -- TAB
                c == 0x0a or -- LF
                c == 0x0d or -- CR
                c == 0x85    -- NEL
            then chars:add(char(c))
            elseif
                c <= 0x001f or -- C0 control block
                c == 0x007f    -- DEL
            then chars:add(format('\\x%02x', c))
            elseif
                (0x0080 <= c and c <= 0x009f) or -- C1 control block
                (0xd800 <= c and c <= 0xdfff) or -- Surrogate block
                c == 0xfffe or
                c == 0xffff
            then chars:add(format('\\u%04x', c))
            else chars:add(char(c))
            end
        end
        str = concat(chars)

        -- Quote.
        return '"' .. str .. '"'
    end

    -- Convert Lua to YAML types.
    local converters = {}
    converters.boolean = tostring
    converters.number = tostring
    converters.string = scalarify

    --- Generate a YAML representation of a value.
    --
    -- Terminates lines with @{EOL}.
    --
    -- @caveats
    --
    -- * Mangles strings in encodings other than UTF-8.
    -- * Does *not* escape *all* non-printable characters (because Unicode).
    --
    -- @param val A value.
    -- @int[opt=4] ind How many spaces to indent blocks.
    -- @treturn[1] string A YAML string.
    -- @raise An error if the value cannot be represented in YAML.
    --
    -- @function yamlify
    yamlify = type_check('?*', '?number', '?number', '?table')(
        function (val, ind, _col, _seen)
            if not _seen then _seen = {} end
            assert(not _seen[val], 'cycle in data tree.')
            if not ind then ind = 4 end
            assert(ind > 0, 'number of spaces must be greater than 0.')
            local t = type(val)
            local conv = converters[t]
            if conv then return conv(val) end
            assert(t == 'table', t .. ': cannot be expressed in YAML.')
            _seen[val] = true
            if not _col then _col = 0 end
            local strs = Values()
            local n = #val
            local nkeys = select(2, keys(val))
            local sp = spaces(_col)
            if n == nkeys then
                local col = _col + 2
                for i = 1, n do
                    local v = val[i]
                    if i > 1 then strs:add(sp) end
                    strs:add('- ', yamlify(v, ind, col, _seen))
                    if i ~= n then strs:add(EOL) end
                end
            else
                local i = 0
                for k, v in pairs(val) do
                    i = i + 1
                    if type(k) == 'number' then k = tostring(k)
                                           else k = scalarify(k, true)
                    end
                    if i > 1 then strs:add(sp) end
                    strs:add(k, ':')
                    local col = _col + ind
                    if type(v) == 'table' then strs:add(EOL, spaces(col))
                                          else strs:add ' '
                    end
                    strs:add(yamlify(v, ind, col, _seen))
                    if i ~= nkeys then strs:add(EOL) end
                end
            end
            return concat(strs)
        end
    )
end

--- Convert Zotero pseudo-HTML to proper HTML.
--
-- @string pseudo Zotero pseudo-HTML code.
-- @treturn[1] string HTML code.
-- @treturn[2] nil `nil` if opening and closing ´<sc>´ tags are unbalanced.
-- @treturn[2] string An error message.
--
-- @function zotero_to_html
zotero_to_html = type_check('string')(
    function (pseudo)
        local opened, closed, n, m
        opened, n = pseudo:gsub('<sc>', '<span class="smallcaps">')
        closed, m = opened:gsub('</sc>', '</span>')
        if n == m then return closed end
        return nil, format('encountered %d <sc> but %d </sc> tags.', n, m)
    end
)

do
    -- Shorthand.
    local read = pandoc.read

    --- Convert Zotero pseudo-HTML to Markdown.
    --
    -- @require
    --
    -- Only supports [pseudo-HTML that Pandoc recognises in bibliographic
    -- data](https://pandoc.org/MANUAL.html#specifying-bibliographic-data)
    -- if run with Pandoc < v2.17.
    --
    -- @string pseudo Zotero pseudo-HTML code.
    -- @treturn[1] string Markdown text.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    --
    -- @function zotero_to_markdown
    zotero_to_markdown = type_check('string')(protect(
        function (pseudo)
            local html, err = zotero_to_html(pseudo)
            if not html then return nil, err end
            local ok, result = pcall(read, html, 'html')
            if not ok then return nil, result end
            return markdownify(result)
        end
    ))
end


------------
-- CSL items
--
-- @section

--- Preferred order of CSL variables.
--
-- @see csl_vars_sort
CSL_VARS_ORDER = {
    'id',                       -- Item ID.
    'citekey',                  -- Citation key (CSL v1.2).
    'type',                     -- For example, 'paper', 'book'.
    'author',                   -- Author(s).
    'original-author',          -- Original author(s).
    'recipient',                -- Recipient of the document.
    'status',                   -- Publication status (e.g., 'forthcoming').
    'issued',                   -- When the item was published.
    'original-date',            -- Original date.
    'title',                    -- The title.
    'title-short',              -- A short version of the title.
    'short-title',              -- Ditto.
    'translator',               -- Translator(s).
    'editor',                   -- The editor(s).
    'container-title',          -- Publication the item was published in.
    'container-title-short',    -- A short version of that title.
    'collection-title',         -- E.g., a series.
    'collection-title-short',   -- A short version of the title.
    'edition',                  -- Container's edition.
    'volume',                   -- Volume no.
    'issue',                    -- Issue no.
    'page-first',               -- First page.
    'page',                     -- Pages or page range *or* number of pages.
    'publisher',                -- Publisher.
    'publisher-place',          -- City/cities the item was published in.
    'original-title',           -- Original title.
    'original-publisher',       -- Original publisher.
    'original-publisher-place', -- Place the item was originally published in.
    'url',                      -- The URL.
    'accessed',                 -- When the URL was last accessed.
    'doi',                      -- The DOI.
    'pmcid',                    -- PubMed Central reference number.
    'pmid',                     -- PubMed reference number.
    'isbn',                     -- The ISBN of the item.
    'issn',                     -- The ISSN of the container.
    'call-number',              -- Call number (of a library).
    'language',                 -- Language the item is in.
    'abstract',                 -- The abstract.
}

do
    --- Normalise a CSL key-value pair.
    --
    -- @string key A CSL key.
    -- @string val A value.
    -- @treturn[1] string A normalised CSL key.
    -- @treturn[1] string A trimmed value.
    -- @see csl_varname_normalise
    local function normalise (key, val)
        if not key or not val then return end
        key = csl_varname_normalise(key)
        if not key then return end
        return key, trim(val)
    end

    -- Iterate over "extra" field entries.
    --
    -- Uses the newer `<name>: <value><linefeed>` syntax.
    --
    -- @string extra A Zotero "extra" field.
    -- @treturn func A *stateful* iterator.
    local function extras_modern (extra)
        local next_line = split(extra, '\r?\n')
        return function ()
            while true do
                local ln = next_line()
                while ln and ln:match '^%s*$' do ln = next_line() end
                if not ln then return end
                local k, v = normalise(tabulate(split(ln, '%s*:%s*'), 2))
                if k then return k, v end
            end
        end
    end

    -- Iterate over legacy "extra" field entries.
    --
    -- Uses the older `{:<name>: <value>}` syntax.
    --
    -- @caveats The syntax is poorly documented,
    --  it's unclear whether this function does the right thing.
    --
    -- @string extra A Zotero "extra" field.
    -- @treturn func A *stateful* iterator.
    local function extras_legacy (extra)
        local next_pair = extra:gmatch '{:([%a-]+):%s*([^}]+)}'
        return function ()
            while true do
                local k, v = next_pair()
                if not k then return end
                k, v = normalise(k, v)
                if k then return k, v end
            end
        end
    end

    --- Iterate over every key-value pair in the "note" field of a CSL item.
    --
    -- @caveats
    --
    -- Assumes that the "note" field is used to store entries that
    -- were added to Zotero's ["extra" field](https://perma.cc/EGN3-78CH).
    --
    -- @tab item A CSL item.
    -- @treturn func A *stateful* iterator.
    --
    -- @see csl_item_add_extras
    -- @function csl_item_extras
    csl_item_extras = type_check('table')(
        function (item)
            local extras = item.note
            if not extras then return function () return end end
            local iters = {extras_modern(extras), extras_legacy(extras)}
            local i = 1
            local iter = iters[i]
            return function ()
                while iter do
                    local k, v = iter()
                    if k then return k, v end
                    i = i + 1
                    iter = iters[i]
                end
            end
        end
    )
end

do
    local date_names = {'from', 'to'}
    local part_names = {'year', 'month', 'day'}

    -- Parse a date in Zotero's extra field.
    --
    -- @caveats The item is modified in-place.
    --
    -- @tab item A CSL item.
    -- @string key A field name.
    -- @string val A value.
    -- @raise An error if the date cannot be parsed.
    local function parse_date (item, key, val)
        -- luacheck: ignore assert
        local i, j
        local function msgh (err)
            return item.id or 'unknown item'
                   .. ': ' .. key
                   .. ': ' .. err:format(date_names[i], part_names[j])
        end
        local assert = asserter(nil, msgh)
        local date = {}
        i = 0
        for iso in split(val, '/') do
            i = i + 1
            assert(i < 3, 'too many dates.')
            local parts = {}
            j = 0
            for part in split(iso, '-') do
                if not part or part == '' then break end
                j = j + 1
                assert(j < 4, '%s date: too many date parts.')
                assert(part:match '^%d+$', '%s date: %s is not a number.')
                parts[j] = part
            end
            assert(j > 0, 'missing %s date.')
            date[i] = parts
        end
        assert(i > 0, 'is empty.')
        item[key] = {['date-parts'] = date}
    end

    -- Parse a name in Zotero's extra field.
    --
    -- @caveats The item is modified in-place.
    --
    -- @tab item A CSL item.
    -- @string key A field name.
    -- @string val A value.
    local function parse_name (item, key, val)
        local family, given = tabulate(split(val, '%s*%|%|%s*', 2))
        if not item[key] then item[key] = {} end
        if family and family ~= '' and given and given ~= ''
            then insert(item[key], {family = family, given = given})
            else insert(item[key], val)
        end
    end

    -- Mapping of CSL field names to functions that take an item and a field
    -- name-value pair and *add* that field to the CSL item *in-place*.
    local parsers = {
        ['accessed'] = parse_date,
        ['container'] = parse_date,
        ['event-date'] = parse_date,
        ['issued'] = parse_date,
        ['original-date'] = parse_date,
        ['submitted'] = parse_date,
        ['author'] = parse_name,
        ['collection-editor'] = parse_name,
        ['composer'] = parse_name,
        ['container-author'] = parse_name,
        ['director'] = parse_name,
        ['editor'] = parse_name,
        ['editorial-director'] = parse_name,
        ['managing-editor'] = parse_name,
        ['illustrator'] = parse_name,
        ['interviewer'] = parse_name,
        ['original-author'] = parse_name,
        ['recipient'] = parse_name,
        ['reviewed-author'] = parse_name,
        ['translator'] = parse_name
    }

    --- Add CSL variables from the "note" field to the item proper.
    --
    -- @side May print error messages to STDERR.
    --
    -- @tab item A CSL item.
    -- @treturn[1] table The item with variables from "extra" copied over.
    -- @treturn[2] nil `nil` if an "extra" field cannot be parsed.
    -- @treturn[2] string An error message.
    --
    -- @function csl_item_add_extras
    csl_item_add_extras = type_check('table')(protect(
        function (item)
            local ret = copy(item)
            for k, v in csl_item_extras(item) do
                if v == '' then
                    return nil, format('%s: %s: is empty.',
                                       item.id or 'unknown item', k)
                else
                    local f = parsers[k]
                    if not ret[k] or f == parse_date or k == 'type' then
                        if f then
                            f(ret, k, v)
                        -- At least until CSL v1.2 is out and
                        -- 'citekey' becomes official.
                        elseif k ~= 'citation-key' and k ~= 'citekey' then
                            ret[k] = v
                        end
                    end
                end
            end
            return ret
        end
    ))
end



-- @fixme
do
    -- Shorthands
    local floor = math.floor

    -- Convert numbers to strings.
    --
    -- Floating point numbers are converted to integers.
    --
    -- @param num A number.
    -- @treturn[1] string A string.
    -- @treturn[2] nil `nil` if the given value is not a number.
    local function num_to_str (num)
        if type(num) == 'number' then return tostring(floor(num)) end
    end

    -- Normalise variable names of a CSL item.
    --
    -- @tab item A CSL item.
    -- @treturn tab A normalised item.
    -- @see csl_varname_normalise
    --
    -- @function csl_item_normalise_vars
    local function csl_item_normalise_vars (item, _seen)
        if     not _seen   then _seen = {}
        elseif _seen[item] then return _seen[item]
        end
        local ret = {}
        _seen[item] = ret
        for k, v in pairs(item) do
            if type(k) == 'string' then
                k = csl_varname_normalise(k)
            end
            if k then
                if type(v) == 'table' then
                    v = csl_item_normalise_vars(v, _seen)
                end
                ret[k] = v
            end
        end
        return ret
    end

    -- @fixme
    -- @fixme Conversion of numbers is not unit-tested.
    csl_item_normalise = type_check('table')(
        function (item)
            return csl_item_normalise_vars(walk(item, num_to_str))
        end
    )
end

do
    -- A mapping of Lua type names to functions that construct Pandoc types.
    local converters = {}

    --- Convert a CSL Item to a Pandoc metadata type (worker).
    --
    -- @tab item CSL item.
    -- @param ... Passed on to per-type conversion function.
    -- @treturn pandoc.MetaValue A Pandoc metadata value.
    -- @raise An error if an item cannot be converted.
    local function convert (item, ...)
        local t = type(item)
        local f = converters[t]
        if f then return f(item, ...) end
        error(t .. ': cannot be converted to a Pandoc metadata value.', 0)
    end

    -- Convert a Lua boolean to a pandoc.MetaBool
    --
    -- @bool bool A boolean value.
    -- @treturn pandoc.MetaBool The value.
    function converters.boolean (bool)
        return pandoc.MetaBool(bool)
    end

    -- Convert a Lua number to a pandoc.MetaInlines string.
    --
    -- @bool num A number.
    -- @treturn pandoc.MetaInlines The number.
    function converters.number (num)
        return MetaInlines(List:new{Str(tostring(num))})
    end

    -- Convert Zotero pseudo-HTML to a pandoc.MetaInlines string.
    --
    -- @string str A string.
    -- @treturn pandoc.MetaInlines A string.
    -- @treturn[2] nil `nil` if a string cannot be converted.
    -- @treturn[2] string An error message.
    -- @raise An error if Zotero pseudo-HTML cannot be parsed.
    function converters.string (str)
        local html, err = zotero_to_html(str)
        if not html then error(err, 0) end
        local doc = pandoc.read(html, 'html')
        local inlines
        pcall(function () inlines = doc.blocks[1].content end)
        return MetaInlines(inlines or List:new())
    end

    -- Convert a Lua table to a pandoc.MetaMapping.
    --
    -- @tab tab A table.
    -- @treturn pandoc.MetaMapping The table.
    -- @fixme Recursion protection is not unit-tested.
    function converters.table (tab, _seen)
        if     not _seen  then _seen = {}
        elseif _seen[tab] then error 'cycle in data tree.'
        end
        _seen[tab] = true
        local n = select(2, keys(tab))
        if n == #tab then
            local list = MetaList{}
            for i = 1, n do list[i] = convert(tab[i], _seen) end
            return list
        end
        local mapping = MetaMap{}
        for k, v in pairs(tab) do mapping[k] = convert(v, _seen) end
        return mapping
    end

    --- Convert a CSL item to a Pandoc metadata value.
    --
    -- This allows to use CSL items in the `references` metadata field.
    --
    -- @tab item A CSL item.
    -- @treturn[1] pandoc.MetaValue A Pandoc metadata value.
    -- @treturn[2] nil `nil` if a value cannot be converted.
    -- @treturn[2] string An error message.
    --
    -- @function csl_item_to_meta
    -- @fixme Not unit-tested.
    csl_item_to_meta = type_check('table')(
        function (item)
            local ok, result = pcall(convert, item)
            if ok then return result end
            return nil, (item.id or 'unknown item') .. ': ' .. result
        end
    )
end

--- Filter CSL items by their citation key.
--
-- @side May print error messages to STDERR.
--
-- @tparam {tab,...} items CSL items.
-- @string ckey A citation key (e.g., `'doe:2020word'`, `'DoeWord2020'`).
-- @treturn {tab,...} Items with that citation key.
--
-- @function csl_items_filter_by_ckey
csl_items_filter_by_ckey = type_check('table', 'string')(
    function (items, ckey)
        local filtered = Values()
        for i = 1, #items do
            local item = items[i]
            for k, v in csl_item_extras(item) do
                if k == 'citation-key' or k == 'citekey' then
                    if v == '' then
                        xwarn(item.id or 'unknown item', ': ${k}: is empty.')
                    elseif v:lower() == ckey:lower() then
                        filtered:add(item)
                        break
                    end
                end
            end
        end
        return filtered
    end
)

--- Pick the IDs of CSL items out of a list of CSL items.
--
-- @side May print error messages to STDERR.
--
-- @tparam {tab,...} items CSL items.
-- @treturn Set Item IDs.
--
-- @function csl_items_ids
csl_items_ids = type_check('table')(
    function (items)
        local ids = {}
        for i = 1, #items do
            local id = items[i].id
            local t = type(id)
            if t == 'number'   then
                id = tostring(id)
            elseif t == 'userdata' or t == 'table' then
                id = stringify(id)
            end
            if type(id) == 'string' and id ~= ''
                then ids[id] = true
                else xwarn('@error', 'ignoring CSL item without parsable ID.')
            end
        end
        return ids
    end
)

--- Sort CSL items by their ID.
--
-- @caveats Assumes that CSL item IDs are of the same type.
--
-- @tab a A CSL item.
-- @tab b Another CSL item.
-- @treturn bool Whether item A comes before item B.
--
-- @function csl_items_sort
csl_items_sort = type_check('table', 'table')(
    function (a, b)
        return a.id < b.id
    end
)

--- Normalise a CSL variable name.
--
-- Trim the variable name, lowercase it, and replace spaces with dashes.
--
-- @string var A CSL variable name.
-- @treturn[1] string A normalised variable name.
-- @treturn[2] nil `nil` if the string is not a CSL variable name.
-- @treturn[2] string An error message.
--
-- @usage
-- > csl_varname_normalise 'Original date'
-- original-date
--
-- @function csl_varname_normalise
csl_varname_normalise = type_check('string')(
    function (var)
        var = trim(var)
        if var == '' then
            return nil, 'variable name is the empty string.'
        elseif var:match '[^%a%s%-]' then
            return nil, var .. ': not a CSL variable.'
        end
        return var:gsub(' ', '-'):lower()
    end
)

--- Sort CSL variables.
--
-- Sorts variables in the order in which they are listed in @{CSL_VARS_ORDER}.
-- Unlisted variables are placed after listed ones in lexical order.
--
-- @string a A CSL variable name.
-- @string b Another CSL variable name.
-- @treturn bool Whether variable A should come before variable B.
--
-- @function csl_vars_sort
csl_vars_sort = type_check('string', 'string')(order(CSL_VARS_ORDER))

do
    -- Run the decoder in protected mode.
    local decode = protect(json.decode)

    --- Parse a CSL JSON string that describes one or more CSL items.
    --
    -- @string str A CSL JSON string.
    -- @treturn[1] tab A single CSL item or a list of CSL items.
    -- @treturn[2] nil `nil` if the string does not describe a CSL item.
    -- @treturn[2] string An error message.
    --
    -- @function csl_json_parse
    csl_json_parse = type_check('string')(
        function (str)
            local data, err = decode(str)
            local t = type(data)
            -- All seems well.
            if t == 'table' then
                return csl_item_normalise(data)
            -- Recent versions of zotxt report errors in JSON.
            elseif t == 'string' then
                return nil, data
            -- Old versions of zotxt report errors in non-JSON text.
            elseif t == 'nil' then
                return nil, err
            end
            -- This point should never be reached.
            return nil, str .. ': not a CSL item.'
        end
    )
end


----------------
-- Citation keys
-- @section

--- A mapping of citation key types to parsers.
--
-- A parser must take a citation key and return search terms or
-- `nil` if no search terms can be derived from the citation key.
CITEKEY_PARSERS = {}

do
    local lower = text.lower

    -- Check whether a number represents a digit in ASCII.
    --
    -- @number n A number.
    -- @treturn bool Whether the number encodes a digit.
    local function is_digit (n)
        -- Digits start at 48 and end at 57 in ASCII.
        return 48 <= n and n <= 57
    end

    --- Guess search terms from a BetterBibTeX citation key.
    --
    -- Splits up a BetterBibTeX citation key at each uppercase letter
    -- and at each start of a string of digits.
    --
    -- @caveats Non-letter characters must be encoded in ASCII.
    --
    -- @string ckey A BetterBibTeX citation key (e.g., `'DoeWord2020'`).
    -- @treturn {string,...} Search terms.
    --
    -- @function CITEKEY_PARSERS.betterbibtexkey
    CITEKEY_PARSERS.betterbibtexkey = type_check('string')(
        function (ckey)
            assert(ckey ~= '', 'citation key is the empty string.')
            local terms = Values()
            local sep = 1
            local prev
            for pos, code in codes(ckey) do
                local add = false
                if pos > 1 then
                    if is_digit(code) ~= is_digit(prev) then
                        add = true
                    else
                        local chr = char(code)
                        -- `chr ~= lower(chr)` is `false` for non-letters.
                        if chr ~= lower(chr) then
                            add = true
                        end
                    end
                end
                if add then
                    terms:add(ckey:sub(sep, pos - 1))
                    sep = pos
                end
                prev = code
            end
            terms:add(ckey:sub(sep))
            return terms
         end
    )
end

--- Guess search terms from an Easy Citekey.
--
-- Splits up an Easy Citekey into an author, a year, and a word.
--
-- @string ckey A zotxt Easy Citekey (e.g., `'doe:2020word'`).
-- @treturn {string,...} Search terms.
--
-- @function CITEKEY_PARSERS.easykey
CITEKEY_PARSERS.easykey = type_check('string')(
    function (ckey)
        assert(ckey ~= '', 'citation key is the empty string.')
        local terms = Values()
        local pivot = 1
        for pos, code in codes(ckey) do
            if pivot > 1 then
                -- Numbers range from 48 to 57 in ASCII/UTF-8.
                if 48 > code or code > 57 then
                    local year = ckey:sub(pivot, pos - 1)
                    if year and year ~= '' then terms:add(year) end
                    local title = ckey:sub(pos)
                    if title and title ~= '' then terms:add(title) end
                    return terms
                end
            -- The colon is encoded as 58 in ASCII/UTF-8.
            elseif code == 58 then
                local pre = ckey:sub(pivot, pos - 1)
                if pre and pre ~= '' then terms:add(pre) end
                pivot = pos + 1
            end
        end
        local year = ckey:sub(pivot)
        if year and year ~= '' then terms:add(year) end
        return terms
    end
)

do
    -- This makes sure that whether a key is an Easy Citekey is checked before
    -- it is checked whether it is a Better BibTeX key.
    local order = order{'easykey'}

    --- Guess search terms from a citation key.
    --
    -- @caveats The key must be supported by a parser in @{CITEKEY_PARSERS}.
    --
    -- @string ckey A citation key (e.g., `'doe:2020word'`, `'DoeWord2020'`).
    -- @tparam {string,...} types Types to try to parse the citation key as.
    -- @treturn[1] {string,...} Search terms.
    -- @treturn[2] nil `nil` if no search terms could be derived.
    -- @treturn[2] string An error message.
    --
    -- @function citekey_terms
    citekey_terms = type_check('string', 'table')(
        function (ckey, types)
            types = update({}, types)
            sort(types, order)
            for _, t in pairs(types) do
                local parse = CITEKEY_PARSERS[t]
                if parse then
                    local terms = parse(ckey)
                    if terms and terms.n > 1 then return terms end
                end
            end
            return nil, format('cannot guess search terms for %s.', ckey)
        end
    )
end

--- A mapping of citation key type names to type guessing functions.
--
-- A type guessing function should take a citation key and return `true` if
-- that key *could be* (not "is") of that type and `false` otherwise.
CITEKEY_TYPIFIERS = {}

do
    -- Raise error if string contains non-printable or non-ASCII characters.
    --
    -- @string str The string.
    local function assert_printable_ascii (str)
        for _, c in codes(str) do assert(33 <= c and c <= 126) end
    end

    --- Check if a citation key could be a Better BibTeX citation key.
    --
    -- @string ckey A citation key.
    -- @treturn bool Whether the key could be a Better BibTeX key.
    --
    -- @function CITEKEY_TYPIFIERS.betterbibtexkey
    -- @fixme Not unit-tested.
    CITEKEY_TYPIFIERS.betterbibtexkey = type_check('string')(
        function (ckey)
            return pcall(assert_printable_ascii, ckey)
        end
    )
end

--- Check if a citation key is a Zotero item ID.
--
-- @string ckey A citation key.
-- @treturn bool Whether the citation key is a Zotero item ID.
--
-- @function CITEKEY_TYPIFIERS.key
-- @fixme Not unit-tested.
CITEKEY_TYPIFIERS.key = type_check('string')(
    function (ckey)
        return ckey:len() == 8 and ckey:match '^[%u%d]+$'
    end
)

--- Check whether a citation key could be of a type.
--
-- @string ckey A citation key.
-- @tab {string,...} Citation key types.
-- @treturn {string,...} Citation key types that would fit the key.
--
-- @function citekey_types
-- @fixme Not unit-tested.
citekey_types = type_check('string', 'table')(
    function (ckey, types)
        local n = #types
        if n == 1 then return types end
        local result = Values()
        for i = 1, n do
            local t = types[i]
            local typify = CITEKEY_TYPIFIERS[t]
            if not typify or typify(ckey) then result:add(t) end
        end
        return result
    end
)


---------------------
-- Bibliography files
-- @section

--- An interface for reading, writing, and updating bibliography files.
--
-- @object biblio
-- @proto @{Object}
biblio = Object:clone()

--- A case-insensitive mapping of filename suffices to codecs.
--
-- @fixme Discuss codec protocol.
biblio.types = setmetatable({}, ignore_case)

--- De-/Encode BibLaTeX files.
biblio.types.bib = {}

--- Parse the contents of a BibLaTeX file.
--
-- @string str The contents of a BibLaTeX file.
-- @treturn[1] {tab,...} CSL items.
-- @treturn[2] nil `nil` if the contents could not be parsed.
-- @treturn[2] string An error message.
--
-- @require Only returns a list of mappings of the literal
--  'id' to CSL item IDs if run with Pandoc < v2.17.
--
-- @function biblio.types.bib.decode
-- @fixme Not unit-tested.
if not pandoc.types or PANDOC_VERSION < {2, 17} then
    biblio.types.bib.decode = type_check('string')(
        function (str)
            local ids = Values()
            for id in str:gmatch '@%w+%s*{%s*([^%s,]+)' do
                ids:add{id = id}
            end
            return ids
        end
    )
else
    biblio.types.bib.decode = type_check('string')(protect(
        function (str)
            local doc = pandoc.read(str, 'biblatex')
            local refs
            pcall(function () refs = doc.meta.references end)
            return refs or {}
        end
    ))
end

--- Serialise a list of CSL items to a BibLaTeX string.
--
-- @tparam {tab,...} items CSL items.
-- @treturn[1] string A BibLaTeX string.
-- @treturn[2] nil `nil` if the items could not be serialised.
-- @treturn[2] string An error message.
--
-- @require Pandoc ≥ 2.17.
--
-- @function biblio.types.bibtex.encode
-- @fixme Not unit-tested.
if pandoc.types and PANDOC_VERSION >= {2, 17} then
    biblio.types.bib.encode = type_check('table')(protect(
        function (items)
            items = map(items, fatalise(csl_item_to_meta))
            local doc = Pandoc({}, Meta{references = items})
            return pandoc.write(doc, 'biblatex')
        end
    ))
end

--- De-/Encode BibTeX files.
biblio.types.bibtex = {}

--- Parse the contents of a BibTeX file.
--
-- @string str The contents of a BibTeX file.
-- @treturn[1] {tab,...} CSL items.
-- @treturn[2] nil `nil` if the contents could not be parsed.
-- @treturn[2] string An error message.
--
-- @require Only returns a list of mappings of the literal
--  'id' to CSL item IDs if run with Pandoc < v2.17.
--
-- @function biblio.types.bibtex.decode
-- @fixme Not unit-tested.
if not pandoc.types or PANDOC_VERSION < {2, 17} then
    biblio.types.bibtex.decode = biblio.types.bib.decode
else
    biblio.types.bibtex.decode = type_check('string')(protect(
        function (str)
            local doc = pandoc.read(str, 'bibtex')
            local refs
            pcall(function () refs = doc.meta.references end)
            return refs or {}
        end
    ))
end

--- Serialise a list of CSL items to a BibTeX string.
--
-- @tparam {tab,...} items CSL items.
-- @treturn[1] string A BibTeX string.
-- @treturn[2] nil `nil` if the items could not be serialised.
-- @treturn[2] string An error message.
--
-- @require Pandoc ≥ 2.17.
--
-- @function biblio.types.bibtex.encode
-- @fixme Not unit-tested.
if pandoc.types and PANDOC_VERSION >= {2, 17} then
    biblio.types.bibtex.encode = type_check('table')(protect(
        function (items)
            items = map(items, fatalise(csl_item_to_meta))
            local doc = Pandoc({}, Meta{references = items})
            return pandoc.write(doc, 'bibtex')
        end
    ))
end

--- De-/Encode CSL items in JSON.
biblio.types.json = {}

--- Parse a CSL JSON string.
--
-- @string str A CSL JSON string.
-- @treturn {tab,...} CSL items.
-- @treturn[2] nil `nil` if the string could not be parsed.
-- @treturn[2] string An error message.
--
-- @function biblio.types.json.decode
biblio.types.json.decode = csl_json_parse

--- Serialise a list of CSL items to a JSON string.
--
-- @tparam {tab,...} items CSL items.
-- @treturn[1] string A CSL JSON string.
-- @treturn[2] nil `nil` if the items could not be serialised.
-- @treturn[2] string An error message.
--
-- @function biblio.types.json.encode
biblio.types.json.encode = type_check('table')(protect(json.encode))

--- De-/Encode CSL items in YAML.
biblio.types.yaml = {}

do
    --- Parse a CSL YAML string.
    --
    -- @caveats Converts formatting to Markdown, not Zotero pseudo-HTML.
    --
    -- @string str A CSL YAML string.
    -- @treturn[1] {tab,...} CSL items.
    -- @treturn[2] nil `nil` if the string could not be parsed.
    -- @treturn[2] string An error message.
    --
    -- @function biblio.types.yaml.decode
    biblio.types.yaml.decode = type_check('string')(protect(
        function (str)
            local next_line = str:gmatch '(.-)\r?\n'
            local ln = next_line(str, nil)
            while ln and ln ~= '---' do ln = next_line(str, ln) end
            if not ln then str = concat{'---', EOL, str, EOL, '...', EOL} end
            local doc = pandoc.read(str, 'markdown')
            local refs
            pcall(function () refs = doc.meta.references end)
            if not refs then return {} end
            refs = elem_walk(refs, {
                -- Pandoc ≥ v2.17.
                Blocks = markdownify,
                Inlines = markdownify,
                -- Pandoc < v2.17.
                MetaBlocks = markdownify,
                MetaInlines = markdownify
            })
            for i = 1, #refs do refs[i] = csl_item_normalise(refs[i]) end
            return refs
        end
    ))
end

do
    -- Run walkers in protected mode.
    -- luacheck: ignore walk
    local walk = protect(walk)

    -- Run yamlify in protected mode.
    local yamlify = protect(yamlify)

    -- Convert Zotero pseudo-HTML to Markdown in CSL fields.
    --
    -- @param value A field value.
    -- @treturn[1] string Markdown text if the value contained pseudo-HTML.
    -- @treturn[2] nil `nil` if the value is not a `string`.
    -- @raise An error if a string cannot be parsed.
    local function to_markdown (value)
        if type(value) ~= 'string' then return end
        local md, err = zotero_to_markdown(value)
        if md then return md end
        error(format('cannot convert "%s" to Markdown: %s', value, err))
    end

    --- Serialise a list of CSL items to a YAML string.
    --
    -- @tparam {tab,...} items CSL items.
    -- @treturn[1] string A CSL YAML string.
    -- @treturn[2] nil `nil` if the items could not be serialised.
    -- @treturn[2] string An error message.
    --
    -- @function biblio.types.yaml.encode
    biblio.types.yaml.encode = type_check('table')(
        function (items)
            -- The Markdown writer appears to ignore metadata.
            for i = 1, #items do
                local item = items[i]
                local v, err = walk(item, to_markdown)
                if not v then
                    local id = item.id or 'unknown item'
                    return nil, id .. ': ' .. err
                end
                items[i] = v
            end
            return yamlify{references = items}
        end
    )
end

--- Alternative suffix for YAML files.
biblio.types.yml = biblio.types.yaml

--- Read a bibliography file.
--
-- The filename suffix determines the file's format.
-- @{biblio.types} must contain a matching decoder.
--
-- @string fname A filename.
-- @treturn[1] Values CSL items.
-- @treturn[2] nil `nil` if an error occurred.
-- @treturn[2] string An error message.
-- @treturn[2] ?int An error number.
--
-- @function biblio:read
biblio.read = type_check('table', 'string')(protect(
    function (self, fname)
        -- luacheck: ignore assert
        assert(fname ~= '', 'filename is the empty string')
        local assert = asserter(nil, function (err)
            return path_prettify(fname) .. ': ' .. err
        end)
        local suffix = assert(fname:match '%.(%w+)$', 'no filename suffix')
        local codec = self.types[suffix]
        local decode
        if codec then decode = codec.decode end
        assert(decode, 'unparsable file type.')
        local str, err, errno = file_read(fname)
        if not str then return nil, err, errno end
        local items = assert(decode(str))
        items.n = #items
        return Values:clone(items)
    end
))

--- Write bibliographic data to a bibliography file.
--
-- The filename suffix determines the file's format.
-- @{biblio.types} must contain a matching encoder.
--
-- If no CSL items are given, tests whether data can be serialised
-- in the given format *without* chaging the file.
--
-- @caveats See @{file_write}.
--
-- @string fname A filename.
-- @tab[opt] items CSL items.
-- @treturn[1] string The filename suffix.
-- @treturn[2] nil `nil` if an error occurred.
-- @treturn[2] string An error message.
-- @treturn[2] ?int An error number.
--
-- @function biblio:write
biblio.write = type_check('table', 'string', '?table')(protect(
    function (self, fname, items)
        assert(fname ~= '', 'filename is the empty string')
        -- luacheck: ignore assert
        local assert = asserter(nil, function (err)
            return path_prettify(fname) .. ': ' .. err
        end)
        local suffix = assert(fname:match '%.(%w+)$', 'no filename suffix')
        local codec = self.types[suffix]
        local encode
        if codec then encode = codec.encode end
        assert(encode, 'unwritable file type.')
        if not items or #items == 0 then return suffix end
        local str = assert(encode(items))
        return file_write(fname, str, EOL)
    end
))

do
    local sort_csl_vars = update({sort = csl_vars_sort}, sort_pairs)

    --- Add new items from Zotero to a bibliography file.
    --
    -- @caveats See @{file_write}.
    -- @side May print error messages to STDERR.
    --
    -- @tparam connectors.Zotxt|connectors.ZoteroWeb handle A Zotero handle.
    -- @string fname The name of the bibliography file.
    -- @tparam {string,...} ckeys The citation keys of the items to add
    --  (e.g., `{'doe:2020word'}`).
    -- @treturn[1] bool `true` if the file was updated or no update was required.
    -- @treturn[2] nil `nil` if an error occurrs.
    -- @treturn[2] string An error message.
    -- @treturn[2] ?int An error number if the error is a file I/O error.
    -- @raise See @{connectors.Zotxt} and @{connectors.ZoteroWeb}.
    --
    -- @function biblio:update
    biblio.update = type_check('table', 'table', 'string', 'table')(protect(
        function (self, handle, fname, ckeys)
            -- luacheck: ignore fmt err errno
            assert(fname ~= '', 'filename is the empty string')
            if #ckeys == 0 then return true end
            local ok, err = self:write(fname)
            if not ok then return nil, err end
            local items, err, errno = biblio:read(fname)
            if not items then
                if errno ~= 2 then return nil, err, errno end
                items = Values()
            end
            local ids = csl_items_ids(items)
            local n = items.n
            for i = 1, #ckeys do
                local ckey = ckeys[i]
                if not ids[ckey] then
                    local item, err = handle:fetch(ckey)
                    if item then items:add(item)
                            else xwarn('@error', '@plain', err)
                    end
                end
            end
            if n == items.n then return true end
            sort(items, csl_items_sort)
            for i = 1, #items do setmetatable(items[i], sort_csl_vars) end
            return self:write(fname, items)
        end
    ))
end


-------------------
-- Document parsing
--
-- @section

--- Make a shallow copy of a Pandoc AST element.
--
-- @tparam pandoc.AstElement elem A Pandoc AST element.
-- @treturn pandoc.AstElement The clone.
-- @fixme Not unit-tested.
--
-- @function elem_clone
if not pandoc.types or PANDOC_VERSION < {2, 15} then
    elem_clone = type_check('table')(
        function (elem)
            if elem.clone then return elem:clone() end
            return update({}, elem)
        end
    )
else
    elem_clone = type_check('table|userdata')(
        function (elem)
            if elem.clone then return elem:clone() end
            local clone = {}
            for k, v in pairs(elem) do
                local t = type(v)
                if t == 'userdata' or t == 'table' then
                    if v.clone then clone[k] = v:clone()
                            else clone[k] = copy(v)
                    end
                end
            end
            assert(elem_type(elem) == 'Pandoc', 'expected a Pandoc document.')
            return Pandoc(clone.blocks, clone.meta)
        end
    )
end

do
    -- A mapping of types to their higher-order types.
    local super = {
        Meta = 'AstElement',
        MetaValue = 'AstElement',
        MetaBlocks = 'Meta',
        MetaBool = 'Meta',
        MetaInlines = 'Meta',
        MetaList = 'Meta',
        MetaMap = 'Meta',
        MetaString = 'Meta',
        Block = 'AstElement',
        BlockQuote = 'Block',
        BulletList = 'Block',
        CodeBlock = 'Block',
        DefinitionList = 'Block',
        Div = 'Block',
        Header = 'Block',
        HorizontalRule = 'Block',
        LineBlock = 'Block',
        Null = 'Block',
        OrderedList = 'Block',
        Para = 'Block',
        Plain = 'Block',
        RawBlock = 'Block',
        Values = 'Block',
        Inline = 'AstElement',
        Cite = 'Inline',
        Code = 'Inline',
        Emph = 'Inline',
        Image = 'Inline',
        LineBreak = 'Inline',
        Link = 'Inline',
        Math = 'Inline',
        Note = 'Inline',
        Quoted = 'Inline',
        RawInline = 'Inline',
        SmallCaps = 'Inline',
        SoftBreak = 'Inline',
        Space = 'Inline',
        Span = 'Inline',
        Str = 'Inline',
        Strikeout = 'Inline',
        Strong = 'Inline',
        Subscript = 'Inline',
        Superscript = 'Inline',
        Underline = 'Inline'
    }

    -- Get the type of list items, if all list are of the same type.
    --
    -- @tparam pandoc.List items Items.
    -- @treturn[1] string A Pandoc AST type.
    -- @treturn[2] nil `nil` if the given value is not a list.
    -- @treturn[2] string An error message.
    local function items_type (items, ...)
        local cnt = {}
        local n = 0
        while true do
            local i = n + 1
            local item = items[i]
            if item == nil then break end
            n = i
            local et, est = elem_type(item, ...)
            if not et or not est then break end
            cnt[est] = cnt[est] or 0 + 1
        end
        local st, ntypes = next(cnt)
        if st and n == ntypes then return st end
        return nil, 'not a list of Pandoc elements.'
    end

    -- Get the type of a Pandoc element (worker).
    --
    -- @tparam pandoc.AstElement el A Pandoc AST element.
    -- @treturn[1] string A type (e.g., 'Str').
    -- @treturn[2] nil `nil` if the given value is not a Pandoc AST element.
    -- @treturn[2] string An error message.
    --
    -- @function et_type
    local el_type
    if not pandoc.types or PANDOC_VERSION < {2, 15} then
        function el_type (el, ...)
            if type(el) == 'table' then
                -- This works even if elem.tag does not.
                local mt = getmetatable(el)
                if mt and mt.__type and mt.__type.name then
                    return mt.__type.name
                end

                -- Lists of similar AST elements.
                local lt = items_type(el, ...)
                if lt then return lt .. 's' end
            end
            return nil, 'not a Pandoc AST element.'
        end
    elseif PANDOC_VERSION < {2, 17} then
        function el_type (el, ...)
            local t = type(el)
            if t == 'userdata' or t == 'table' then
                -- Use the tag, if there is one.
                if el.tag then return el.tag end

                -- Lists of AST elements of the same type (e.g., 'Inlines').
                if t == 'table' then
                    local lt = items_type(el, ...)
                    if lt then return lt .. 's' end
                end

                -- If this point is reached, then there is no better way to
                -- determine whether an element is a Pandoc document.
                if
                    el.meta   and
                    el.blocks and
                    t == 'userdata'
                then return 'Pandoc' end
            end
            return nil, 'not a Pandoc AST element.'
        end
    else
        local pandoc_type = pandoc.utils.type

        function el_type (el)
            local t = type(el)
            if t == 'userdata' or t == 'table' then
                -- Use the tag, if there is one.
                if el.tag then return el.tag end

                -- Otherwise, use pandoc.utils.type.
                local et = pandoc_type(el)
                if
                    et:match '^[A-Z]' and
                    et ~= 'Meta'      and
                    et ~= 'List'
                then return et end
            end
            return nil, 'not a Pandoc AST element.'
        end
    end

    --- Get the type of a Pandoc AST element.
    --
    -- @tparam pandoc.AstElement elem A Pandoc AST element.
    -- @treturn[1] string A type (e.g., 'Str').
    -- @treturn[1] string|nil A super-type (e.g., 'Block' or 'Meta').
    -- @treturn[1] string|nil ⋮.
    -- @treturn[2] nil `nil` if the given value is not a Pandoc AST element.
    -- @treturn[2] string An error message.
    --
    -- @function elem_type
    function elem_type (elem, _seen)
        if     not _seen   then _seen = {}
        elseif _seen[elem] then error 'cycle in data tree.'
        end
        _seen[elem] = true
        local et, err = el_type(elem, _seen)
        if not et then return nil, err end
        local ets = Values()
        while et do
            ets:add(et)
            et = super[et]
        end
        return unpack(ets)
    end
end

do
    -- Walk a Lua table.
    local function walk_table (tab, ...)
        for k, v in pairs(tab) do tab[k] = elem_walk(v, ...) end
    end

    --- Walk a *List AST element (e.g., `pandoc.OrderedList`).
    local function walk_list_elem (elem, ...)
        local content = elem.content
        for i = 1, #content do walk_table(content[i], ...) end
    end

    -- Walk a document.
    local function walk_doc (doc, ...)
        doc.meta = elem_walk(doc.meta, ...)
        walk_table(doc.blocks, ...)
    end

    -- Walking functions by Pandoc AST element type.
    local walkers = {
        Meta = walk_table,
        MetaBlocks = walk_table,
        MetaList = walk_table,
        MetaInlines = walk_table,
        MetaMap = walk_table,
        BulletList = walk_list_elem,
        OrderedList = walk_list_elem,
        Inlines = walk_table,
        Blocks = walk_table,
        Metas = walk_table,
        Pandoc = walk_doc
    }

    --- Walk an AST and apply a filter to matching elements.
    --
    -- Differs from Pandoc's walkers by:
    --
    -- * walking AST elements of any type (inluding documents and metadata),
    -- * walking the AST bottom-up,
    -- * *not* accepting the `traverse` keyword,
    -- * applying the filter to the given element itself,
    -- * allowing functions in the filter to return data of arbitrary types,
    -- * never modifying the original element, and
    -- * accepting 'AstElement' as type that matches any element.
    --
    -- @tparam pandoc.AstElement elem A Pandoc AST element.
    -- @tparam {string=func,...} filter A filter.
    -- @return Typically but not necessarily, a new Pandoc AST element.
    --
    -- @function elem_walk
    elem_walk = type_check('*', 'table', '?table')(
        function (elem, filter, _seen)
            if not _seen then _seen = {} end
            assert(not _seen[elem], 'cycle in data tree.')
            local ets = {elem_type(elem)}
            local et = ets[1]
            if et then
                _seen[elem] = true
                elem = elem_clone(elem)
                local walker = walkers[et]
                if walker then
                    walker(elem, filter, _seen)
                elseif elem.content then
                    walk_table(elem.content, filter, _seen)
                end
                for i = 1, #ets do
                    local func = filter[ets[i]]
                    if func then
                        local new = func(elem)
                        if new ~= nil then elem = new end
                    end
                end
            elseif type(elem) == 'table' then
                _seen[elem] = true
                if elem.clone then elem = elem:clone()
                              else elem = update({}, elem)
                end
                walk_table(elem, filter, _seen)
            end
            return elem
        end
    )
end

--- Collect bibliographic data.
--
-- Reads the `references` metadata field and every bibliography file.
--
-- @tparam pandoc.Pandoc doc A document.
-- @treturn[1] {tab,...} CSL items.
-- @treturn[2] nil `nil` if an error occurred.
-- @treturn[2] string An error message.
--
-- @function doc_srcs
doc_srcs_legacy = type_check('table|userdata')(protect(
    function (doc)
        -- luacheck: ignore assert
        local assert = asserter()
        local data = {}
        if not doc or not doc.meta then return data end
        local meta = doc.meta
        if meta.references then extend(data, meta.references) end
        if meta.bibliography then
            local opts = assert(opts_parse(meta, {
                name = 'bibliography',
                type = 'list'
            }))
            local fnames = opts.bibliography
            for i = 1, #fnames do
                -- luacheck: ignore err
                local fname = assert(file_locate(fnames[i]))
                local items = assert(biblio:read(fname))
                extend(data, items)
            end
        end
        return data
    end
))

-- @fixme The error messages of `pandoc.utils.references`
--        are sometimes unhelpful.
if not pandoc.types or PANDOC_VERSION < {2, 17}
    then doc_srcs = doc_srcs_legacy
    else doc_srcs = type_check('table|userdata')(
        protect(pandoc.utils.references)
    )
end

--- Collect the citation keys used in a document.
--
-- @tparam pandoc.Pandoc doc A document.
-- @bool[opt] undef Collect only undefind citation keys?
-- @treturn[1] {string,...} Citation keys.
-- @treturn[1] int The number of citation keys found.
-- @treturn[2] nil `nil` if an error occurred.
-- @treturn[2] string An error message.
--
-- @function doc_ckeys
doc_ckeys = type_check('table|userdata', '?boolean')(
    function (doc, undef)
        local meta = doc.meta or {}
        local blocks = doc.blocks
        local ckeys = {}
        local filter = {
            Cite = function (cite)
                ckeys = update(ckeys, csl_items_ids(cite.citations))
            end
        }
        for k, v in pairs(meta) do
            if k ~= 'references' then elem_walk(v, filter) end
        end
        for i = 1, #blocks do
            pandoc.walk_block(blocks[i], filter)
        end
        if undef then
            local srcs, err = doc_srcs(doc)
            if not srcs then return nil, err end
            for ckey in pairs(csl_items_ids(srcs)) do
                ckeys[ckey] = nil
            end
        end
        return keys(ckeys)
    end
)


-----------------
-- Option parsing
-- @section

--- An option definition
--
-- @string name An option name.
-- @string[opt='string'] type A type to coerce the option's value to.
-- @func[opt] parse A parser.
-- @string[opt] prefix A prefix.
--
-- @caveats This table exists in documentation only.
-- @see opts_parse
-- @table Option

--- An option parser.
--
-- @see Options:new
-- @see Options:add
-- @see Options:parse
-- @object Options
-- @proto @{Values}
Options = Values:clone()

--- Create a new option parser.
--
--    parser = Options:new{name = 'foo'}
--
-- is equivalent to:
--
--    parser = Options()
--    parser:add{name = 'foo'}
--
-- @tparam Option ... Options.
--
-- @see Options:add
-- @function Options:new
Options.new = type_check('table', {
    name = 'string',
    type = '?string',
    parse = '?function',
    prefix = '?string'
})(Values.new)

--- Add an option to the parser.
--
-- @tparam Option ... Options.
--
-- @usage
-- parser = Options()
-- parser:add{
--     name = 'bar',
--     type = 'number',
--     parse = function (x)
--         if x < 1 return return nil, 'not a positive number.' end
--         return x
--     end
-- }
--
-- @see opts_parse
-- @see Options:parse
-- @function Options:add
Options.add = type_check('table', {
    name = 'string',
    type = '?string',
    parse = '?function',
    prefix = '?string'},
'...')(Values.add)

--- Read configuration options from a metadata block.
--
-- @tparam pandoc.MetaMap meta A metadata block.
-- @treturn[1] tab A mapping of option names to values.
-- @treturn[2] nil `nil` if an error occurred.
-- @treturn[2] string An error message.
--
-- @usage
-- > meta = pandoc.MetaMap{
-- >     ['foo-bar'] = pandoc.MetaInlines(pandoc.List{
-- >         pandoc.Str "0123"
-- >     })
-- > parser = Options()
-- > parser:add{
-- >     name = 'bar',
-- >     type = 'number',
-- >     parse = function (x)
-- >         if x < 1 return return nil, 'not a positive number.' end
-- >         return x
-- >     end
-- > }
-- > opts = parser:parse(meta)
-- > opts.bars
-- 123
-- > type(opts.bar)
-- number
--
-- @see opts_parse
-- @see Options:add
-- @function Options:parse
Options.parse = type_check('table', 'table|userdata')(
    function (self, meta)
        return opts_parse(meta, unpack(self))
    end
)

do
    local pandoc_type = pandoc.utils.type

    -- Run stringify in protected mode.
    -- luacheck: ignore stringify
    local stringify = protect(stringify)

    -- A mapping of configuration value types to parers.
    local converters = {}

    -- Convert a configuration value to a type.
    --
    -- @param val A value.
    -- @string[opt='string'] type A type declaration.
    --  See @{opts_parse} for the grammar.
    -- @return[1] A value of the given type.
    -- @treturn[2] nil `nil` if the value cannot be converted.
    -- @treturn[2] string An error message.
    -- @raise An error if a type declaration cannot be parsed.
    local function convert (val, decl)
        if not decl then decl = 'string' end
        local head, tail = decl:match '^%s*(%l+)%s*<?%s*([%l<>%s]-)%s*>?%s*$'
        if not head then error(decl .. ': cannot parse.', 3) end
        local conv = converters[head]
        if not conv then error(head .. ': no such type.', 3) end
        return conv(val, tail or 'string')
    end

    -- Convert a value to a Lua string.
    --
    -- @param val A value.
    -- @treturn[1] string A string.
    -- @treturn[2] nil `nil` if the value cannot be converted to a string.
    -- @treturn[2] string An error message.
    -- @todo Test whether stringify could do all the work.
    function converters.string (val)
        local t = type(val)
        if t == 'string' then
            return val
        elseif t == 'number' then
            return tostring(val)
        elseif elem_type(val) then
            local str = stringify(val)
            if str ~= '' then return str end
        end
        return nil, 'not a string or empty.'
    end

    -- Convert a value to a Lua number.
    --
    -- @param val A value.
    -- @treturn[1] number A number.
    -- @treturn[2] nil `nil` if the value cannot be converted to a number.
    -- @treturn[2] string An error message.
    function converters.number (val)
        if type(val) == 'number' then return val end
        if elem_type(val) then val = stringify(val) end
        local num = tonumber(val)
        if num then return num end
        return nil, 'not a number.'
    end

    -- Convert values to lists.
    --
    -- Tables are passed through as is.
    --
    -- @param val A value or list of values.
    -- @treturn pandoc.List A list of values.
    function converters.list (val, decl)
        if decl == '' then decl = 'string' end
        local function conv (v) return convert(v, decl) end
        local t = type(val)
        if t == 'userdata' or t == 'table' then
            if pandoc_type then
                local pt = pandoc_type(val)
                if pt == 'List' then return val:map(conv) end
            else
                local et = elem_type(val)
                if et == 'MetaList' then
                    return val:map(conv)
                elseif t == 'table' and not et then
                    return List(val):map(conv)
                end
            end
        end
        return List:new{conv(val)}
    end

    --- Read configuration options from a metadata block.
    --
    -- <h3>Mapping of option names to metadata fieldnames:</h3>
    --
    -- The name of the metadata field that is looked up by @{Options:parse} is
    -- the name of the option with underscores replaced by dashes. If the
    -- option has a prefix, then the fieldname is prefixed with that prefix
    -- and a dash *after* underscores have been replaced with dashes.
    --
    -- In Lua:
    --
    --    fieldname = name:gsub('_', '-')
    --    if prefix then fieldname = prefix .. '-' .. fieldname end
    --
    -- <h3>Type declaration grammar:</h3>
    --
    -- Configuration values can be of one of three types:
    --
    -- * 'number'
    -- * 'string'
    -- * 'list'
    --
    -- If you declare an option to be of the scalar types 'number' or
    -- 'string', its value is required to be of the Lua type of the
    -- same name. Values are converted automatically if possible.
    --
    -- If you declare an option to be of the type 'list', its value is
    -- required to be a `pandoc.List`. If a scalar is encountered where
    -- a list was expected, the value is wrapped in a single-item list.
    --
    -- The items of a list must all be of the same type, which you declare by
    -- appending '<*T*>' to the literal 'list', where *T* is either the name
    -- of a scalar type or another list declaration and defaults to 'string'.
    --
    -- In [Extended Backus-Naur Form](https://en.wikipedia.org/wiki/EBNF):
    --
    -- > Scalar = ( 'number' | 'string' )
    -- >
    -- > List = 'list', [ '<', ( scalar | list ), '>' ]
    --
    -- No type checks or conversions are performed for `nil`.
    --
    -- <h3>Parse protocol:</h3>
    --
    -- A parser is a function that takes the converted value and
    -- returns a new one or `nil` and an error message.
    --
    -- Parsers are not called for `nil`.
    --
    -- @tparam pandoc.MetaMap meta A metadata block.
    -- @tparam Option ... Options.
    -- @treturn tab A mapping of option names to values.
    --
    -- @usage
    -- > meta = pandoc.MetaMap{
    -- >     ['foo-bar'] = pandoc.MetaInlines(pandoc.List{
    -- >         pandoc.Str "0123"
    -- >     })
    -- > opts = opts_parse(meta, {
    -- >     name = 'bar',
    -- >     type = 'number',
    -- >     parse = function (x)
    -- >         if x < 1 return return nil, 'not a positive number.' end
    -- >         return x
    -- >     end
    -- > })
    -- > opts.bars
    -- 123
    -- > type(opts.bar)
    -- number
    --
    -- @see Options
    -- @function opts_parse
    opts_parse = type_check('table|userdata', {
        name = 'string',
        type = '?string',
        parse = '?function',
        prefix = '?string'
    }, '...')(
        function (meta, ...)
            local opts = {}
            local defs = pack(...)
            if not meta or defs.n == 0 then return opts end
            for i = 1, defs.n do
                local def = defs[i]
                local key = def.name:gsub('_', '-')
                if def.prefix then key = def.prefix .. '-' .. key end
                local val = meta[key]
                if val ~= nil then
                    -- luacheck: ignore err
                    local err
                    for _, func in pairs{convert, def.parse} do
                        if not func then break end
                        val, err = func(val, def.type)
                        if not val then return nil, key .. ': ' .. err end
                    end
                    opts[def.name] = val
                end
            end
            return opts
        end
    )
end


--------------------
-- Zotero connectors
-- @section

--- A case-insensitive namespace for connector prototypes.
--
-- <h3>Connector protocol:</h3>
--
-- A connector prototype *must* provide two methods:
--
-- * `new`: Called to create handles.
--   Must have the same function signature as @{Object:new} and
--   return `nil` and an error message if the handle cannot be created.
--
-- * `fetch`: Called to fetch bibliographc data. Must take a citation key and
--   return either a CSL item or `nil` and an error message.
--
-- Connector prototypes may register configuration settings by providing
-- an `options` property that points to an @{Options} object. That object's
-- @{Options:parse} method is then called with the document's metadata block
-- as argument and whatever it returns is passed on to `new`.
connectors = setmetatable({}, ignore_case)

--- Interface to [zotxt](https://github.com/egh/zotxt).
--
-- @usage
-- handle = connectors.Zotxt()
-- item = handle:fetch 'DoeWord2020'
--
-- @object connectors.Zotxt
-- @proto @{Object}
connectors.Zotxt = Object:clone()

--- Zotero options.
--
-- Defines `zotero-citekey-types`.
-- See the [manual](#content) for details.
--
-- @object connectors.Zotxt.options
-- @proto @{Options}.
connectors.Zotxt.options = Options{
    prefix = 'zotero',
    name = 'citekey_types',
    type = 'list'
}

--- Types of citation keys to expect.
--
-- List of @{string}s. For example, `{'betterbibtexkey', 'easykey'}`.
connectors.Zotxt.citekey_types = {
    'betterbibtexkey',  -- Better BibTeX citation key
    'easykey',          -- zotxt easy citekey
    'key',              -- Zotero item ID
}

do
    -- URL of the endpoint to look up items at.
    local base_url = 'http://localhost:23119/zotxt/items?%s=%s'

    --- Fetch a CSL item via zotxt.
    --
    -- @side May re-order the elements of @{connectors.Zotxt.citekey_types}.
    --
    -- @string ckey A citation key (e.g., `'doe:2020word'`, `'DoeWord2020'`).
    -- @treturn[1] table A CSL item.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    -- @raise See @{http_get}.
    --
    -- @function connectors.Zotxt:fetch
    connectors.Zotxt.fetch = type_check({citekey_types = 'table'}, 'string')(
        function (self, ckey)
            local ts = citekey_types(ckey, self.citekey_types)
            local err = ckey .. ': unrecognised type of citation key.'
            for i = 1, #ts do
                local t = ts[i]
                -- zotxt supports searching for multiple citation keys at
                -- once, but if a single one cannot be found, it replies
                -- with a cryptic error message (for Easy Citekeys) or an
                -- empty response (for Better BibTeX citation keys).
                local query_url = base_url:format(t, ckey)
                local ok, mt, str = pcall(http_get, query_url)
                if not ok then
                    error('failed to connect to Zotero desktop client.', 0)
                end
                if not mt or mt == '' or not str or str == '' then
                    if t == 'betterbibtexkey'
                        then err = ckey .. ': no matches.'
                        else err = ckey .. ': zotxt response is empty.'
                    end
                elseif not mt:match ';%s*charset="?utf%-?8"?%s*$' then
                    err = ckey .. ': zotxt response not encoded in UTF-8.'
                else
                    -- luacheck: ignore ok
                    local ok, data = pcall(json.decode, str)
                    if not ok then
                        err = 'zotxt responded: ' .. str
                    elseif type(data) == 'table' then
                        local n = #data
                        if n == 1 then
                            local citekey_types = self.citekey_types
                            if citekey_types[1] ~= t then
                                local j = select(2, find(citekey_types, t))
                                remove(citekey_types, j)
                                insert(citekey_types, 1, t)
                            end
                            local item = csl_item_normalise(data[1])
                            item.id = ckey
                            return item
                        end
                        if n == 0 then err = ckey .. ': no matches.'
                                  else err = ckey .. ': too many matches.'
                        end
                    elseif type(data) == 'string' then
                        err = 'zotxt responded: ' .. str
                    else
                        err = ckey .. ': cannot parse zotxt response: ' .. str
                    end
                end
            end
            return nil, err
        end
    )
end

--- Interface to [Zotero's Web API](https://www.zotero.org/support/dev/web_api)
--
-- @string[opt] api_key A Zotero Web API key.
-- @number[opt] user_id A Zotero user ID.
-- @tparam[opt] {number,...} groups Zotero groups to search in.
-- @tparam[opt] {number,...} public_groups Public Zotero groups to search in.
--
-- @usage
-- handle = connectors.ZoteroWeb{api_key = 'a0Bc1De2Fg3Hi4Jk5Lm6No7'}
-- item = handle:fetch 'DoeWord2020'
--
-- @object connectors.ZoteroWeb
-- @proto @{connectors.Zotxt}
connectors.ZoteroWeb = connectors.Zotxt:clone()

--- Types of citation keys to expect.
--
-- See @{connectors.Zotxt.citekey_types} for details
-- and @{citekey_terms} for caveats.
connectors.ZoteroWeb.citekey_types = List {
    'key',              -- Zotero item IDs
    'easykey',          -- zotxt Easy Citekey
    'betterbibtexkey',  -- Better BibTeX citation key
}

--- Zotero Web API options.
--
-- Defines:
--
--  * `zotero-api-key`
--  * `zotero-user-id`
--  * `zotero-groups`
--  * `zotero-public-groups`
--
-- See the [manual](#content) for details.
--
-- @object connectors.ZoteroWeb.options
-- @proto @{connectors.Zotxt.options}.
connectors.ZoteroWeb.options = connectors.Zotxt.options(
    {prefix = 'zotero', name = 'api_key'},
    {prefix = 'zotero', name = 'user_id', type = 'number'},
    {prefix = 'zotero', name = 'groups', type = 'list<number>'},
    {prefix = 'zotero', name = 'public_groups', type = 'list<number>'}
)

do
    -- Zotero Web API base URL.
    local base_url = 'https://api.zotero.org'

    -- URL template for user ID lookups.
    local user_id_url = base_url .. '/keys/${api_key}'

    -- URL template for group membership lookups.
    local groups_url = base_url .. '/users/${user_id}/groups'

    -- User prefix.
    local user_prefix = '/users/${user_id}'

    -- Group prefix.
    local group_prefix = '/groups/${group_id}'

    -- URL template for item lookups.
    local items_url = base_url .. '${prefix}/items/${id}'

    --- Metatable for Zotero Web API connectors.
    connectors.ZoteroWeb.mt = getmetatable(connectors.ZoteroWeb)

    --- Getters for Zotero Web API connectors.
    --
    -- @see getterify
    connectors.ZoteroWeb.mt.getters = {}

    --- Get the user ID for the given API key.
    --
    -- @tparam connectors.ZoteroWeb obj A Zotero Web API handle.
    -- @treturn string A Zotero user ID.
    -- @raise An error if
    --
    -- * the `api_key` field is not set.
    -- * the Zotero Web API could not be reached (see @{http_get} for details),
    -- * the API's response cannot be parsed, or
    -- * no user ID could be found for the given Zotero API key.
    --
    -- @function connectors.ZoteroWeb.mt.getters.user_id
    connectors.ZoteroWeb.mt.getters.user_id = type_check('table')(
        function (obj)
            -- luacheck: ignore err
            -- @fixme Test if this is ever raised!
            assert(obj.api_key, 'no Zotero API key given.')
            local ep = assert(vars_sub(user_id_url, obj))
            local data, err = obj.query(ep, {v = 3})
            if data then
                local user_id = data.userID
                if not user_id then
                    err = format('no user for API key %s.', obj.api_key)
                else
                    obj.user_id = user_id
                    return user_id
                end
            end
            error('Zotero user ID lookup: ' .. err, 0)
        end
    )

    --- Get the groups the user is a member of.
    --
    -- @tparam connectors.ZoteroWeb obj A Zotero Web API handle.
    -- @treturn {string,...} Zotero group IDs.
    -- @raise An error if
    --
    -- * the `api_key` field is not set.
    -- * the Zotero Web API could not be reached
    --   (see @{http_get} for details), or
    -- * the API's response cannot be parsed.
    --
    -- @function connectors.ZoteroWeb.mt.getters.groups
    connectors.ZoteroWeb.mt.getters.groups = type_check('table')(
        function (obj)
            -- luacheck: ignore err
            -- @fixme Is this ever raised?
            assert(obj.api_key, 'no Zotero API key given.')
            local ep = assert(vars_sub(groups_url, obj))
            local data, err = obj.query(ep, {v = 3, key = obj.api_key})
            if data then
                local groups = Values()
                for i = 1, #data do
                    if data[i] and data[i].data and data[i].data.id then
                        groups:add(data[i].data.id)
                    end
                end
                obj.groups = groups
                return groups
            end
            error('Zotero group membership lookup: ' .. err, 0)
        end
    )

    --- Delegate to the Zotero Web API interface.
    --
    -- @function connectors.ZoteroWeb.clone
    -- @see Object:clone
    -- @see getterify
    connectors.ZoteroWeb.clone = type_check('table')(
        function (...)
            return getterify(connectors.Zotxt.clone(...))
        end
    )

    --- Create a new Zotero Web API handle.
    --
    -- @fixme Discuss options.
    connectors.ZoteroWeb.new = type_check('table', {
        api_key = '?string',
        user_id = '?number',
        groups = '?table',
        public_groups = '?table'
    })(
        function (proto, args)
            if args.api_key or args.public_groups then
                return connectors.Zotxt.new(proto, args)
            end
            return nil, 'set an API key or public groups to use the Zotero Web API.'
        end
    )

    --- Retrieve data from the Zotero Web API.
    --
    -- @string ep An endpoint URL.
    -- @tparam {string=string,...} params Request parameters.
    -- @treturn[1] string The response of the Zotero Web API.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    -- @raise See @{http_get}.
    --
    -- @see http_get
    -- @function connectors.ZoteroWeb.query
    -- @fixme Not unit-tested.
    connectors.ZoteroWeb.query = type_check('string', '?table')(
        function (ep, params)
            local query_url = ep
            if params then
                local query = Values:clone()
                for k, v in sorted(params) do query:add(k .. '=' ..v) end
                query_url = query_url .. '?' .. concat(query, '&')
            end
            local ok, mt, str = pcall(http_get, query_url)

            if not ok then error('failed to connect to Zotero Web API.', 0) end
            if not mt or mt == '' then
                return nil, 'Zotero response declares no MIME type.'
            elseif not str or str == '' then
                return nil, 'Zotero response is empty.'
            -- @todo Check encoding of response.
            elseif mt:match '^text/plain' then
                return nil, 'Zotero responded: ' .. str
            elseif not mt:match '%f[%a]json%f[%A]' then
                local err = 'Zotero response is of unexpected MIME type %s.'
                return nil, err:format(mt)
            end
            local data
            ok, data = pcall(json.decode, str)
            if not ok then
                return nil, 'cannot parse Zotero response: ' .. str
            end
            return data
            -- end
            -- return nil, 'Zotero responded: ' .. str
        end
    )

    --- Iterate over item endpoint URLs.
    --
    -- @string[opt] id A Zotero item ID.
    -- @treturn func A *stateful* iterator.
    --
    -- @function connectors.ZoteroWeb:endpoints
    connectors.ZoteroWeb.endpoints = type_check('table', '?string')(
        function (self, id)
            if not id then id = '' end
            local groups, ngroups
            local i = -1
            return function ()
                i = i + 1
                if i == 0 then
                    if self.api_key then
                        return assert(vars_sub(items_url, {
                            prefix = user_prefix,
                            user_id = self.user_id,
                            id = id
                        }))
                    end
                else
                    if not groups then
                        groups = {}
                        if self.api_key then
                            extend(groups, self.groups)
                        end
                        if self.public_groups then
                            extend(groups, self.public_groups)
                        end
                        ngroups = #groups
                    end
                    if i > ngroups then return end
                    return assert(vars_sub(items_url, {
                        prefix = group_prefix,
                        group_id = groups[i],
                        id = id
                    }))
                end
            end
        end
    )

    --- Search items by their author, publication year, and title.
    --
    -- @caveats Does *not* correct Zotero's CSL JSON export.
    --
    -- @string ... Search terms.
    -- @treturn[1] tab CSL items that match the given search terms.
    -- @treturn[2] nil `nil` if no items were found or an error occurred.
    -- @treturn[2] string An error message.
    -- @treturn[2] An error message.
    -- @raise See @{connectors.ZoteroWeb.mt.getters.user_id} and
    --  @{connectors.ZoteroWeb.mt.getters.groups}.
    --
    -- @function connectors.ZoteroWeb:search
    connectors.ZoteroWeb.search = type_check(
        {
            endpoints = 'function',
            query = 'function'
        },
        'string',
        '?string',
        '...'
    )(
        function (self, ...)
            local q = concat({...}, '+')
            local params = {v = 3, key = self.api_key,
                            q = q, qmode = 'titleCreatorYear',
                            format ='csljson', itemType='-attachment'}
            for ep in self:endpoints() do
                -- luacheck: ignore err
                local data, err = self.query(ep, params)
                if not data then return nil, err end
                local items = data.items
                if items and #items > 0 then
                    return map(items, csl_item_normalise)
                end
            end
            return nil, 'no matches.'
        end
    )

    --- Look up a CSL item by its Zotero ID.
    --
    -- @string id A Zotero item ID.
    -- @treturn[1] tab A CSL item.
    -- @treturn[2] nil `nil` if no or more than one item has been found.
    -- @treturn[2] string An error message.
    -- @raise See @{connectors.ZoteroWeb.mt.getters.user_id} and
    --  @{connectors.ZoteroWeb.mt.getters.groups}.
    --
    -- @function connectors.ZoteroWeb:lookup
    connectors.ZoteroWeb.lookup = type_check({
        endpoints = 'function',
        query = 'function'
    }, 'string')(
        function (self, id)
            local params = {v = 3, key = self.api_key,
                            format ='csljson', itemType='-attachment'}
            for ep in self:endpoints(id) do
                local data = self.query(ep, params)
                if data then
                    local items = data.items
                    if items then
                        local n = #items
                        if n == 1 then
                            -- luacheck: ignore err
                            local err
                            local item = csl_item_normalise(items[1])
                            item, err = csl_item_add_extras(item)
                            if not item then return id .. ': ' .. err end
                            item.id = id
                            return item
                        elseif n > 1 then
                            return nil, format('item ID %s: not unique.', id)
                        end
                    end
                end
            end
            return nil, id .. ': no matches.'
        end
    )

    --- Fetch a CSL item from the Zotero Web API.
    --
    -- @side
    --
    -- Search terms for citation keys are printed to STDERR
    -- if the user has requested verbose output.
    --
    -- @string ckey A citation key (e.g., `'doe:2020word'`, `'DoeWord2020'`).
    -- @treturn[1] table A CSL item.
    -- @treturn[2] nil `nil` if an error occurred.
    -- @treturn[2] string An error message.
    -- @raise See @{connectors.ZoteroWeb.mt.getters.user_id} and
    --  @{connectors.ZoteroWeb.mt.getters.groups}.
    --
    -- @function connectors.ZoteroWeb:fetch
    connectors.ZoteroWeb.fetch = type_check({
        citekey_types = 'table',
        lookup = 'function',
        search = 'function'
    }, 'string')(
        function (self, ckey)
            -- luacheck: ignore err
            assert(ckey ~= '', 'citation key is the empty string.')
            if includes(citekey_types(ckey, self.citekey_types), 'key') then
                return self:lookup(ckey)
            end
            local terms, err = citekey_terms(ckey, self.citekey_types)
            if not terms then return nil, err end
            xwarn('@info', '${ckey}: searching for: ',
                  '@plain', concat(terms, ', '))
            local items, err = self:search(unpack(terms))
            if not items then return nil, ckey .. ': ' .. err end
            local n = #items
            if n == 0 then
                return nil, ckey .. ': no matches.'
            elseif n > 1 then
                items = csl_items_filter_by_ckey(items, ckey)
                if not items or items.n == 0 then
                    return nil, ckey .. ': too many matches.'
                elseif items.n > 1 then
                    return nil, format('citation key %s: not unique.', ckey)
                end
            end
            local item = items[1]
            item.id = ckey
            local err
            item, err = csl_item_add_extras(item)
            if not item then return ckey .. ': ' .. err end
            return item
        end
    )
end


-------
-- Main
--
-- @section

--- Add bibliographic data to a bibliography file.
--
-- Updates the bibliography file as needed and adds its to the
-- `bibliography` metadata field. Interpretes relative filenames
-- as relative to the directory of the first input file passed
-- to **pandoc**, or, if no input files were given, as relative
-- to the current working directory.
--
-- @caveats @{file_write}.
-- @side May print error messages to STDERR.
--
-- @string fname A filename for the bibliography file.
-- @tparam connectors.Zotxt|connectors.ZoteroWeb handle A Zotero handle.
-- @tparam pandoc.Pandoc doc A Pandoc document.
-- @treturn[1] pandoc.Meta An updated metadata block.
-- @treturn[2] nil `nil` if nothing was done or an error occurred.
-- @treturn[2] string An error message, if applicable.
-- @raise See @{connectors.Zotxt} and @{connectors.ZoteroWeb}.
--
-- @function add_biblio
add_biblio = type_check('string', 'table', 'table|userdata')(
    function (fname, handle, doc)
        -- luacheck: ignore err
        assert(fname ~= '', 'bibliography filename is the empty string.')
        local ckeys, err = doc_ckeys(doc, true)
        if not ckeys then return nil, err end
        if #ckeys == 0 then return end
        local meta = doc.meta
        local dir = project_dir()
        assert(dir ~= '', 'directory of first input file is the empty string.')
        if not path_is_abs(fname) then fname = path_join(dir, fname) end
        local ok, err = biblio:update(handle, fname, ckeys)
        if not ok then return nil, err end
        local opts, err = opts_parse(meta, {
            name = 'bibliography',
            type = 'list'
        })
        if not opts then return nil, err end
        local fnames = opts.bibliography or List:new()
        fnames:insert(fname)
        meta.bibliography = fnames
        return meta
    end
)

--- Add bibliographic data to the `references` metadata field.
--
-- @side May print error messages to STDERR.
--
-- @tparam connectors.Zotxt|connectors.ZoteroWeb handle A Zotero handle.
-- @tparam pandoc.Pandoc doc A Pandoc document.
-- @treturn[1] table An updated metadata block.
-- @treturn[2] nil `nil` if nothing was done or an error occurred.
-- @treturn[2] string An error message, if applicable.
-- @raise See @{connectors.Zotxt} and @{connectors.ZoteroWeb}.
--
-- @function add_refs
add_refs = type_check('table', 'table|userdata')(protect(
    function (handle, doc)
        local ckeys, err = doc_ckeys(doc, true)
        if not ckeys then return nil, err end
        local meta = doc.meta
        if #ckeys == 0 then return end
        if not meta.references then meta.references = MetaList({}) end
        local n = #meta.references
        for i = 1, #ckeys do
            -- luacheck: ignore err
            local ckey = ckeys[i]
            local item, err = handle:fetch(ckey)
            if item then
                item, err = csl_item_to_meta(item)
                if item then n = n + 1
                             meta.references[n] = item
                        else xwarn('@error', '@plain', ckey, ': ', err)
                end
            else
                xwarn('@error', '@plain', err)
            end
        end
        return meta
    end
))

do
    local parser = Options(
        {
            prefix = 'zotero',
            name = 'bibliography',
            parse = function (fname)
                return env_sub(fname)
                --return vars_sub(fname, env)
            end
        },
        {
            prefix = 'zotero',
            name = 'connectors',
            type = 'list',
            parse = function (names)
                local conns = Values()
                for i = 1, #names do
                    local name = names[i]
                    if not name:match '^%a[%w_]+$' then
                        return nil, name .. ': not a connector name.'
                    end
                    local conn = connectors[name]
                    if not conn then
                        return nil, name .. ': no such connector.'
                    elseif not type_match(conn, {
                        new = 'function',
                        fetch = 'function'
                    }) then
                        return nil, name .. ': connector violates protocol.'
                    end
                    conns:add(conn)
                end
                return conns
            end
        }
    )

    --- Collect citations and add bibliographic data to the document.
    --
    -- See the [manual](#content) for details.
    --
    -- @side May print error messages to STDERR.
    --
    -- @tparam pandoc.Pandoc doc A document.
    -- @treturn[1] pandoc.Pandoc The document with bibliographic data added.
    -- @treturn[2] nil `nil` if nothing was done or an error occurred.
    -- @treturn[2] ?string An error mesage, if applicable.
    -- @raise See @{connectors.Zotxt} and @{connectors.ZoteroWeb}.
    main = protect(
        function (doc)
            -- luacheck: ignore assert
            local assert = asserter()
            local opts = assert(parser:parse(doc.meta))
            local handles = Values()

            local conns = opts.connectors
            if not conns or #conns == 0 then
                for _, conn in sorted(connectors, order{'zotxt'}) do
                    -- luacheck: ignore opts
                    local args
                    local opts = conn.options
                    if opts then args = assert(opts:parse(doc.meta)) end
                    local handle = conn:new(args)
                    if handle then handles:add(handle) end
                end
            else
                for i = 1, #conns do
                    -- luacheck: ignore opts
                    local conn = conns[i]
                    local opts = conn.options
                    local args
                    if opts then args = assert(opts:parse(doc.meta)) end
                    local handle = assert(conn:new(args))
                    handles:add(handle)
                end
            end

            local add_sources
            local biblio = opts.bibliography
            if biblio then
                function add_sources (...) return add_biblio(biblio, ...) end
            else
                add_sources = add_refs
            end

            local chg = false
            for i = 1, handles.n do
                local meta, err = add_sources(handles[i], doc)
                if meta then
                    doc.meta = meta
                    chg = true
                elseif err then
                    xwarn('@error', '@plain', err)
                end
            end
            if chg then return doc end
        end
    )
end

-- Returning the whole script, rather than only a list of mappings of
-- Pandoc data types to functions, allows to do unit testing.

M[1] = {Pandoc = function (doc)
    local new, err = main(doc)
    if err then xwarn('@error', '@plain', err) end
    return new
end}

return M
